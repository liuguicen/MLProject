// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/caffe/proto/caffe.proto

#ifndef PROTOBUF_src_2fcaffe_2fproto_2fcaffe_2eproto__INCLUDED
#define PROTOBUF_src_2fcaffe_2fproto_2fcaffe_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace caffe {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

class BlobShape;
class BlobProto;
class Datum;
class FillerParameter;
class InnerProductParameter;
class ConvolutionParameter;
class DataParameter;
class TransformationParameter;
class ParamSpec;
class LayerProp;
class LayerParameter;
class ConcatParameter;
class ReLUParameter;
class NoiseParameter;
class SecParameter;
class InterpParameter;
class DropoutParameter;
class ParseEvaluateParameter;
class EltwiseParameter;
class CRFParameter;
class ContextPoolingParameter;
class NormalizeParameter;
class AccuracyParameter;
class ShortcutParameter;
class BatchNormParameter;
class InputBlob;
class NetParameter;
class NetOptimizer;
class SolverState;
class NetState;
class SolverParameter;
class PoolingParameter;
class LossParameter;

// ===================================================================

class BlobShape : public ::google::protobuf::Message {
 public:
  BlobShape();
  virtual ~BlobShape();

  BlobShape(const BlobShape& from);

  inline BlobShape& operator=(const BlobShape& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobShape& default_instance();

  void Swap(BlobShape* other);

  // implements Message ----------------------------------------------

  BlobShape* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobShape& from);
  void MergeFrom(const BlobShape& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dim = 5 [packed = true];
  inline int dim_size() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 5;
  inline ::google::protobuf::int64 dim(int index) const;
  inline void set_dim(int index, ::google::protobuf::int64 value);
  inline void add_dim(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dim() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dim();

  // optional int32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 channels = 2;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 2;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional bool forced = 6 [default = false];
  inline bool has_forced() const;
  inline void clear_forced();
  static const int kForcedFieldNumber = 6;
  inline bool forced() const;
  inline void set_forced(bool value);

  // @@protoc_insertion_point(class_scope:caffe.BlobShape)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_forced();
  inline void clear_has_forced();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dim_;
  mutable int _dim_cached_byte_size_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 width_;
  bool forced_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static BlobShape* default_instance_;
};
// -------------------------------------------------------------------

class BlobProto : public ::google::protobuf::Message {
 public:
  BlobProto();
  virtual ~BlobProto();

  BlobProto(const BlobProto& from);

  inline BlobProto& operator=(const BlobProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobProto& default_instance();

  void Swap(BlobProto* other);

  // implements Message ----------------------------------------------

  BlobProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobProto& from);
  void MergeFrom(const BlobProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 5 [packed = true];
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // repeated float diff = 6 [packed = true];
  inline int diff_size() const;
  inline void clear_diff();
  static const int kDiffFieldNumber = 6;
  inline float diff(int index) const;
  inline void set_diff(int index, float value);
  inline void add_diff(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      diff() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_diff();

  // optional .caffe.BlobShape shape = 7;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 7;
  inline const ::caffe::BlobShape& shape() const;
  inline ::caffe::BlobShape* mutable_shape();
  inline ::caffe::BlobShape* release_shape();
  inline void set_allocated_shape(::caffe::BlobShape* shape);

  // optional int32 num = 1 [default = 0];
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 channels = 2 [default = 0];
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 2;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 height = 3 [default = 0];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 width = 4 [default = 0];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe.BlobProto)
 private:
  inline void set_has_shape();
  inline void clear_has_shape();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > diff_;
  mutable int _diff_cached_byte_size_;
  ::caffe::BlobShape* shape_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static BlobProto* default_instance_;
};
// -------------------------------------------------------------------

class Datum : public ::google::protobuf::Message {
 public:
  Datum();
  virtual ~Datum();

  Datum(const Datum& from);

  inline Datum& operator=(const Datum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Datum& default_instance();

  void Swap(Datum* other);

  // implements Message ----------------------------------------------

  Datum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datum& from);
  void MergeFrom(const Datum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 channels = 1;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 1;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional int32 label = 5;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 5;
  inline ::google::protobuf::int32 label() const;
  inline void set_label(::google::protobuf::int32 value);

  // repeated float float_data = 6;
  inline int float_data_size() const;
  inline void clear_float_data();
  static const int kFloatDataFieldNumber = 6;
  inline float float_data(int index) const;
  inline void set_float_data(int index, float value);
  inline void add_float_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      float_data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_float_data();

  // optional bool encoded = 7 [default = false];
  inline bool has_encoded() const;
  inline void clear_encoded();
  static const int kEncodedFieldNumber = 7;
  inline bool encoded() const;
  inline void set_encoded(bool value);

  // repeated int32 multi_label = 8;
  inline int multi_label_size() const;
  inline void clear_multi_label();
  static const int kMultiLabelFieldNumber = 8;
  inline ::google::protobuf::int32 multi_label(int index) const;
  inline void set_multi_label(int index, ::google::protobuf::int32 value);
  inline void add_multi_label(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      multi_label() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_multi_label();

  // @@protoc_insertion_point(class_scope:caffe.Datum)
 private:
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_encoded();
  inline void clear_has_encoded();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::std::string* data_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 label_;
  ::google::protobuf::RepeatedField< float > float_data_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > multi_label_;
  bool encoded_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static Datum* default_instance_;
};
// -------------------------------------------------------------------

class FillerParameter : public ::google::protobuf::Message {
 public:
  FillerParameter();
  virtual ~FillerParameter();

  FillerParameter(const FillerParameter& from);

  inline FillerParameter& operator=(const FillerParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FillerParameter& default_instance();

  void Swap(FillerParameter* other);

  // implements Message ----------------------------------------------

  FillerParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FillerParameter& from);
  void MergeFrom(const FillerParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1 [default = "msra"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string variance_norm = 2 [default = "fan_in"];
  inline bool has_variance_norm() const;
  inline void clear_variance_norm();
  static const int kVarianceNormFieldNumber = 2;
  inline const ::std::string& variance_norm() const;
  inline void set_variance_norm(const ::std::string& value);
  inline void set_variance_norm(const char* value);
  inline void set_variance_norm(const char* value, size_t size);
  inline ::std::string* mutable_variance_norm();
  inline ::std::string* release_variance_norm();
  inline void set_allocated_variance_norm(::std::string* variance_norm);

  // optional float mean = 3;
  inline bool has_mean() const;
  inline void clear_mean();
  static const int kMeanFieldNumber = 3;
  inline float mean() const;
  inline void set_mean(float value);

  // optional float std = 4;
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 4;
  inline float std() const;
  inline void set_std(float value);

  // @@protoc_insertion_point(class_scope:caffe.FillerParameter)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_variance_norm();
  inline void clear_has_variance_norm();
  inline void set_has_mean();
  inline void clear_has_mean();
  inline void set_has_std();
  inline void clear_has_std();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  static ::std::string* _default_type_;
  ::std::string* variance_norm_;
  static ::std::string* _default_variance_norm_;
  float mean_;
  float std_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static FillerParameter* default_instance_;
};
// -------------------------------------------------------------------

class InnerProductParameter : public ::google::protobuf::Message {
 public:
  InnerProductParameter();
  virtual ~InnerProductParameter();

  InnerProductParameter(const InnerProductParameter& from);

  inline InnerProductParameter& operator=(const InnerProductParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerProductParameter& default_instance();

  void Swap(InnerProductParameter* other);

  // implements Message ----------------------------------------------

  InnerProductParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerProductParameter& from);
  void MergeFrom(const InnerProductParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num_output = 1;
  inline bool has_num_output() const;
  inline void clear_num_output();
  static const int kNumOutputFieldNumber = 1;
  inline ::google::protobuf::uint32 num_output() const;
  inline void set_num_output(::google::protobuf::uint32 value);

  // optional bool bias_term = 2 [default = false];
  inline bool has_bias_term() const;
  inline void clear_bias_term();
  static const int kBiasTermFieldNumber = 2;
  inline bool bias_term() const;
  inline void set_bias_term(bool value);

  // optional .caffe.FillerParameter weight_filler = 3;
  inline bool has_weight_filler() const;
  inline void clear_weight_filler();
  static const int kWeightFillerFieldNumber = 3;
  inline const ::caffe::FillerParameter& weight_filler() const;
  inline ::caffe::FillerParameter* mutable_weight_filler();
  inline ::caffe::FillerParameter* release_weight_filler();
  inline void set_allocated_weight_filler(::caffe::FillerParameter* weight_filler);

  // @@protoc_insertion_point(class_scope:caffe.InnerProductParameter)
 private:
  inline void set_has_num_output();
  inline void clear_has_num_output();
  inline void set_has_bias_term();
  inline void clear_has_bias_term();
  inline void set_has_weight_filler();
  inline void clear_has_weight_filler();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 num_output_;
  bool bias_term_;
  ::caffe::FillerParameter* weight_filler_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static InnerProductParameter* default_instance_;
};
// -------------------------------------------------------------------

class ConvolutionParameter : public ::google::protobuf::Message {
 public:
  ConvolutionParameter();
  virtual ~ConvolutionParameter();

  ConvolutionParameter(const ConvolutionParameter& from);

  inline ConvolutionParameter& operator=(const ConvolutionParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvolutionParameter& default_instance();

  void Swap(ConvolutionParameter* other);

  // implements Message ----------------------------------------------

  ConvolutionParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvolutionParameter& from);
  void MergeFrom(const ConvolutionParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num_output = 1;
  inline bool has_num_output() const;
  inline void clear_num_output();
  static const int kNumOutputFieldNumber = 1;
  inline ::google::protobuf::uint32 num_output() const;
  inline void set_num_output(::google::protobuf::uint32 value);

  // optional bool bias_term = 2 [default = false];
  inline bool has_bias_term() const;
  inline void clear_bias_term();
  static const int kBiasTermFieldNumber = 2;
  inline bool bias_term() const;
  inline void set_bias_term(bool value);

  // optional uint32 pad = 3 [default = 0];
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 3;
  inline ::google::protobuf::uint32 pad() const;
  inline void set_pad(::google::protobuf::uint32 value);

  // optional uint32 kernel_size = 4;
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 kernel_size() const;
  inline void set_kernel_size(::google::protobuf::uint32 value);

  // optional uint32 stride = 5 [default = 1];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 5;
  inline ::google::protobuf::uint32 stride() const;
  inline void set_stride(::google::protobuf::uint32 value);

  // optional uint32 filter_stride = 6 [default = 1];
  inline bool has_filter_stride() const;
  inline void clear_filter_stride();
  static const int kFilterStrideFieldNumber = 6;
  inline ::google::protobuf::uint32 filter_stride() const;
  inline void set_filter_stride(::google::protobuf::uint32 value);

  // optional .caffe.FillerParameter weight_filler = 7;
  inline bool has_weight_filler() const;
  inline void clear_weight_filler();
  static const int kWeightFillerFieldNumber = 7;
  inline const ::caffe::FillerParameter& weight_filler() const;
  inline ::caffe::FillerParameter* mutable_weight_filler();
  inline ::caffe::FillerParameter* release_weight_filler();
  inline void set_allocated_weight_filler(::caffe::FillerParameter* weight_filler);

  // optional uint32 group = 8 [default = 1];
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 8;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);

  // optional string weight_file = 9;
  inline bool has_weight_file() const;
  inline void clear_weight_file();
  static const int kWeightFileFieldNumber = 9;
  inline const ::std::string& weight_file() const;
  inline void set_weight_file(const ::std::string& value);
  inline void set_weight_file(const char* value);
  inline void set_weight_file(const char* value, size_t size);
  inline ::std::string* mutable_weight_file();
  inline ::std::string* release_weight_file();
  inline void set_allocated_weight_file(::std::string* weight_file);

  // optional uint32 multi = 10;
  inline bool has_multi() const;
  inline void clear_multi();
  static const int kMultiFieldNumber = 10;
  inline ::google::protobuf::uint32 multi() const;
  inline void set_multi(::google::protobuf::uint32 value);

  // optional bool random_field = 11 [default = false];
  inline bool has_random_field() const;
  inline void clear_random_field();
  static const int kRandomFieldFieldNumber = 11;
  inline bool random_field() const;
  inline void set_random_field(bool value);

  // @@protoc_insertion_point(class_scope:caffe.ConvolutionParameter)
 private:
  inline void set_has_num_output();
  inline void clear_has_num_output();
  inline void set_has_bias_term();
  inline void clear_has_bias_term();
  inline void set_has_pad();
  inline void clear_has_pad();
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_filter_stride();
  inline void clear_has_filter_stride();
  inline void set_has_weight_filler();
  inline void clear_has_weight_filler();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_weight_file();
  inline void clear_has_weight_file();
  inline void set_has_multi();
  inline void clear_has_multi();
  inline void set_has_random_field();
  inline void clear_has_random_field();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 num_output_;
  ::google::protobuf::uint32 pad_;
  ::google::protobuf::uint32 kernel_size_;
  ::google::protobuf::uint32 stride_;
  ::google::protobuf::uint32 filter_stride_;
  bool bias_term_;
  bool random_field_;
  ::caffe::FillerParameter* weight_filler_;
  ::std::string* weight_file_;
  ::google::protobuf::uint32 group_;
  ::google::protobuf::uint32 multi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static ConvolutionParameter* default_instance_;
};
// -------------------------------------------------------------------

class DataParameter : public ::google::protobuf::Message {
 public:
  DataParameter();
  virtual ~DataParameter();

  DataParameter(const DataParameter& from);

  inline DataParameter& operator=(const DataParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataParameter& default_instance();

  void Swap(DataParameter* other);

  // implements Message ----------------------------------------------

  DataParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataParameter& from);
  void MergeFrom(const DataParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string source = 1;
  inline int source_size() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source(int index) const;
  inline ::std::string* mutable_source(int index);
  inline void set_source(int index, const ::std::string& value);
  inline void set_source(int index, const char* value);
  inline void set_source(int index, const char* value, size_t size);
  inline ::std::string* add_source();
  inline void add_source(const ::std::string& value);
  inline void add_source(const char* value);
  inline void add_source(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& source() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_source();

  // optional string root_folder = 2 [default = ""];
  inline bool has_root_folder() const;
  inline void clear_root_folder();
  static const int kRootFolderFieldNumber = 2;
  inline const ::std::string& root_folder() const;
  inline void set_root_folder(const ::std::string& value);
  inline void set_root_folder(const char* value);
  inline void set_root_folder(const char* value, size_t size);
  inline ::std::string* mutable_root_folder();
  inline ::std::string* release_root_folder();
  inline void set_allocated_root_folder(::std::string* root_folder);

  // optional uint32 batch_size = 3 [default = 1];
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 batch_size() const;
  inline void set_batch_size(::google::protobuf::uint32 value);

  // optional bool shuffle = 5 [default = false];
  inline bool has_shuffle() const;
  inline void clear_shuffle();
  static const int kShuffleFieldNumber = 5;
  inline bool shuffle() const;
  inline void set_shuffle(bool value);

  // optional bool random_skip = 6 [default = false];
  inline bool has_random_skip() const;
  inline void clear_random_skip();
  static const int kRandomSkipFieldNumber = 6;
  inline bool random_skip() const;
  inline void set_random_skip(bool value);

  // @@protoc_insertion_point(class_scope:caffe.DataParameter)
 private:
  inline void set_has_root_folder();
  inline void clear_has_root_folder();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_shuffle();
  inline void clear_has_shuffle();
  inline void set_has_random_skip();
  inline void clear_has_random_skip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> source_;
  ::std::string* root_folder_;
  ::google::protobuf::uint32 batch_size_;
  bool shuffle_;
  bool random_skip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static DataParameter* default_instance_;
};
// -------------------------------------------------------------------

class TransformationParameter : public ::google::protobuf::Message {
 public:
  TransformationParameter();
  virtual ~TransformationParameter();

  TransformationParameter(const TransformationParameter& from);

  inline TransformationParameter& operator=(const TransformationParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransformationParameter& default_instance();

  void Swap(TransformationParameter* other);

  // implements Message ----------------------------------------------

  TransformationParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransformationParameter& from);
  void MergeFrom(const TransformationParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool mirror = 1 [default = true];
  inline bool has_mirror() const;
  inline void clear_mirror();
  static const int kMirrorFieldNumber = 1;
  inline bool mirror() const;
  inline void set_mirror(bool value);

  // optional int32 crop_size = 2 [default = 0];
  inline bool has_crop_size() const;
  inline void clear_crop_size();
  static const int kCropSizeFieldNumber = 2;
  inline ::google::protobuf::int32 crop_size() const;
  inline void set_crop_size(::google::protobuf::int32 value);

  // optional int32 augment_size = 3 [default = 0];
  inline bool has_augment_size() const;
  inline void clear_augment_size();
  static const int kAugmentSizeFieldNumber = 3;
  inline ::google::protobuf::int32 augment_size() const;
  inline void set_augment_size(::google::protobuf::int32 value);

  // repeated float mean_value = 4;
  inline int mean_value_size() const;
  inline void clear_mean_value();
  static const int kMeanValueFieldNumber = 4;
  inline float mean_value(int index) const;
  inline void set_mean_value(int index, float value);
  inline void add_mean_value(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      mean_value() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_mean_value();

  // optional bool alter_color = 5 [default = true];
  inline bool has_alter_color() const;
  inline void clear_alter_color();
  static const int kAlterColorFieldNumber = 5;
  inline bool alter_color() const;
  inline void set_alter_color(bool value);

  // optional bool pad_img = 6 [default = false];
  inline bool has_pad_img() const;
  inline void clear_pad_img();
  static const int kPadImgFieldNumber = 6;
  inline bool pad_img() const;
  inline void set_pad_img(bool value);

  // optional bool simple = 7 [default = false];
  inline bool has_simple() const;
  inline void clear_simple();
  static const int kSimpleFieldNumber = 7;
  inline bool simple() const;
  inline void set_simple(bool value);

  // optional bool center_crop = 8 [default = false];
  inline bool has_center_crop() const;
  inline void clear_center_crop();
  static const int kCenterCropFieldNumber = 8;
  inline bool center_crop() const;
  inline void set_center_crop(bool value);

  // optional int32 ignore_label = 9 [default = 255];
  inline bool has_ignore_label() const;
  inline void clear_ignore_label();
  static const int kIgnoreLabelFieldNumber = 9;
  inline ::google::protobuf::int32 ignore_label() const;
  inline void set_ignore_label(::google::protobuf::int32 value);

  // optional bool random_scale = 10 [default = true];
  inline bool has_random_scale() const;
  inline void clear_random_scale();
  static const int kRandomScaleFieldNumber = 10;
  inline bool random_scale() const;
  inline void set_random_scale(bool value);

  // optional bool random_aspect = 11 [default = false];
  inline bool has_random_aspect() const;
  inline void clear_random_aspect();
  static const int kRandomAspectFieldNumber = 11;
  inline bool random_aspect() const;
  inline void set_random_aspect(bool value);

  // optional int32 resolution = 12 [default = 1];
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 12;
  inline ::google::protobuf::int32 resolution() const;
  inline void set_resolution(::google::protobuf::int32 value);

  // optional int32 classes = 13 [default = 21];
  inline bool has_classes() const;
  inline void clear_classes();
  static const int kClassesFieldNumber = 13;
  inline ::google::protobuf::int32 classes() const;
  inline void set_classes(::google::protobuf::int32 value);

  // optional bool random_rotate = 14 [default = false];
  inline bool has_random_rotate() const;
  inline void clear_random_rotate();
  static const int kRandomRotateFieldNumber = 14;
  inline bool random_rotate() const;
  inline void set_random_rotate(bool value);

  // @@protoc_insertion_point(class_scope:caffe.TransformationParameter)
 private:
  inline void set_has_mirror();
  inline void clear_has_mirror();
  inline void set_has_crop_size();
  inline void clear_has_crop_size();
  inline void set_has_augment_size();
  inline void clear_has_augment_size();
  inline void set_has_alter_color();
  inline void clear_has_alter_color();
  inline void set_has_pad_img();
  inline void clear_has_pad_img();
  inline void set_has_simple();
  inline void clear_has_simple();
  inline void set_has_center_crop();
  inline void clear_has_center_crop();
  inline void set_has_ignore_label();
  inline void clear_has_ignore_label();
  inline void set_has_random_scale();
  inline void clear_has_random_scale();
  inline void set_has_random_aspect();
  inline void clear_has_random_aspect();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_classes();
  inline void clear_has_classes();
  inline void set_has_random_rotate();
  inline void clear_has_random_rotate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 crop_size_;
  ::google::protobuf::int32 augment_size_;
  ::google::protobuf::RepeatedField< float > mean_value_;
  bool mirror_;
  bool alter_color_;
  bool pad_img_;
  bool simple_;
  ::google::protobuf::int32 ignore_label_;
  bool center_crop_;
  bool random_scale_;
  bool random_aspect_;
  bool random_rotate_;
  ::google::protobuf::int32 resolution_;
  ::google::protobuf::int32 classes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static TransformationParameter* default_instance_;
};
// -------------------------------------------------------------------

class ParamSpec : public ::google::protobuf::Message {
 public:
  ParamSpec();
  virtual ~ParamSpec();

  ParamSpec(const ParamSpec& from);

  inline ParamSpec& operator=(const ParamSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParamSpec& default_instance();

  void Swap(ParamSpec* other);

  // implements Message ----------------------------------------------

  ParamSpec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParamSpec& from);
  void MergeFrom(const ParamSpec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lr_mult = 1;
  inline bool has_lr_mult() const;
  inline void clear_lr_mult();
  static const int kLrMultFieldNumber = 1;
  inline float lr_mult() const;
  inline void set_lr_mult(float value);

  // optional float decay_mult = 2;
  inline bool has_decay_mult() const;
  inline void clear_decay_mult();
  static const int kDecayMultFieldNumber = 2;
  inline float decay_mult() const;
  inline void set_decay_mult(float value);

  // optional float weight_norm = 3;
  inline bool has_weight_norm() const;
  inline void clear_weight_norm();
  static const int kWeightNormFieldNumber = 3;
  inline float weight_norm() const;
  inline void set_weight_norm(float value);

  // optional float weight_penalty = 4 [default = 0];
  inline bool has_weight_penalty() const;
  inline void clear_weight_penalty();
  static const int kWeightPenaltyFieldNumber = 4;
  inline float weight_penalty() const;
  inline void set_weight_penalty(float value);

  // @@protoc_insertion_point(class_scope:caffe.ParamSpec)
 private:
  inline void set_has_lr_mult();
  inline void clear_has_lr_mult();
  inline void set_has_decay_mult();
  inline void clear_has_decay_mult();
  inline void set_has_weight_norm();
  inline void clear_has_weight_norm();
  inline void set_has_weight_penalty();
  inline void clear_has_weight_penalty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float lr_mult_;
  float decay_mult_;
  float weight_norm_;
  float weight_penalty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static ParamSpec* default_instance_;
};
// -------------------------------------------------------------------

class LayerProp : public ::google::protobuf::Message {
 public:
  LayerProp();
  virtual ~LayerProp();

  LayerProp(const LayerProp& from);

  inline LayerProp& operator=(const LayerProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerProp& default_instance();

  void Swap(LayerProp* other);

  // implements Message ----------------------------------------------

  LayerProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerProp& from);
  void MergeFrom(const LayerProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float loss_weight = 2 [default = 0];
  inline bool has_loss_weight() const;
  inline void clear_loss_weight();
  static const int kLossWeightFieldNumber = 2;
  inline float loss_weight() const;
  inline void set_loss_weight(float value);

  // optional bool need_backward = 3 [default = true];
  inline bool has_need_backward() const;
  inline void clear_need_backward();
  static const int kNeedBackwardFieldNumber = 3;
  inline bool need_backward() const;
  inline void set_need_backward(bool value);

  // optional float sec_loss_weight = 4 [default = 0];
  inline bool has_sec_loss_weight() const;
  inline void clear_sec_loss_weight();
  static const int kSecLossWeightFieldNumber = 4;
  inline float sec_loss_weight() const;
  inline void set_sec_loss_weight(float value);

  // optional float norm_value = 5 [default = 1];
  inline bool has_norm_value() const;
  inline void clear_norm_value();
  static const int kNormValueFieldNumber = 5;
  inline float norm_value() const;
  inline void set_norm_value(float value);

  // @@protoc_insertion_point(class_scope:caffe.LayerProp)
 private:
  inline void set_has_loss_weight();
  inline void clear_has_loss_weight();
  inline void set_has_need_backward();
  inline void clear_has_need_backward();
  inline void set_has_sec_loss_weight();
  inline void clear_has_sec_loss_weight();
  inline void set_has_norm_value();
  inline void clear_has_norm_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float loss_weight_;
  bool need_backward_;
  float sec_loss_weight_;
  float norm_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static LayerProp* default_instance_;
};
// -------------------------------------------------------------------

class LayerParameter : public ::google::protobuf::Message {
 public:
  LayerParameter();
  virtual ~LayerParameter();

  LayerParameter(const LayerParameter& from);

  inline LayerParameter& operator=(const LayerParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerParameter& default_instance();

  void Swap(LayerParameter* other);

  // implements Message ----------------------------------------------

  LayerParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerParameter& from);
  void MergeFrom(const LayerParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated string bottom = 3;
  inline int bottom_size() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 3;
  inline const ::std::string& bottom(int index) const;
  inline ::std::string* mutable_bottom(int index);
  inline void set_bottom(int index, const ::std::string& value);
  inline void set_bottom(int index, const char* value);
  inline void set_bottom(int index, const char* value, size_t size);
  inline ::std::string* add_bottom();
  inline void add_bottom(const ::std::string& value);
  inline void add_bottom(const char* value);
  inline void add_bottom(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bottom() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bottom();

  // repeated string top = 4;
  inline int top_size() const;
  inline void clear_top();
  static const int kTopFieldNumber = 4;
  inline const ::std::string& top(int index) const;
  inline ::std::string* mutable_top(int index);
  inline void set_top(int index, const ::std::string& value);
  inline void set_top(int index, const char* value);
  inline void set_top(int index, const char* value, size_t size);
  inline ::std::string* add_top();
  inline void add_top(const ::std::string& value);
  inline void add_top(const char* value);
  inline void add_top(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& top() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_top();

  // repeated int32 bottom_flow = 101;
  inline int bottom_flow_size() const;
  inline void clear_bottom_flow();
  static const int kBottomFlowFieldNumber = 101;
  inline ::google::protobuf::int32 bottom_flow(int index) const;
  inline void set_bottom_flow(int index, ::google::protobuf::int32 value);
  inline void add_bottom_flow(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bottom_flow() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bottom_flow();

  // repeated int32 top_flow = 102;
  inline int top_flow_size() const;
  inline void clear_top_flow();
  static const int kTopFlowFieldNumber = 102;
  inline ::google::protobuf::int32 top_flow(int index) const;
  inline void set_top_flow(int index, ::google::protobuf::int32 value);
  inline void add_top_flow(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      top_flow() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_top_flow();

  // optional .caffe.LayerProp include = 5;
  inline bool has_include() const;
  inline void clear_include();
  static const int kIncludeFieldNumber = 5;
  inline const ::caffe::LayerProp& include() const;
  inline ::caffe::LayerProp* mutable_include();
  inline ::caffe::LayerProp* release_include();
  inline void set_allocated_include(::caffe::LayerProp* include);

  // repeated .caffe.ParamSpec param = 6;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 6;
  inline const ::caffe::ParamSpec& param(int index) const;
  inline ::caffe::ParamSpec* mutable_param(int index);
  inline ::caffe::ParamSpec* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe::ParamSpec >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe::ParamSpec >*
      mutable_param();

  // repeated .caffe.BlobProto blobs = 7;
  inline int blobs_size() const;
  inline void clear_blobs();
  static const int kBlobsFieldNumber = 7;
  inline const ::caffe::BlobProto& blobs(int index) const;
  inline ::caffe::BlobProto* mutable_blobs(int index);
  inline ::caffe::BlobProto* add_blobs();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >&
      blobs() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >*
      mutable_blobs();

  // repeated .caffe.LayerParameter branch = 8;
  inline int branch_size() const;
  inline void clear_branch();
  static const int kBranchFieldNumber = 8;
  inline const ::caffe::LayerParameter& branch(int index) const;
  inline ::caffe::LayerParameter* mutable_branch(int index);
  inline ::caffe::LayerParameter* add_branch();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >&
      branch() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >*
      mutable_branch();

  // optional string bind_key = 9;
  inline bool has_bind_key() const;
  inline void clear_bind_key();
  static const int kBindKeyFieldNumber = 9;
  inline const ::std::string& bind_key() const;
  inline void set_bind_key(const ::std::string& value);
  inline void set_bind_key(const char* value);
  inline void set_bind_key(const char* value, size_t size);
  inline ::std::string* mutable_bind_key();
  inline ::std::string* release_bind_key();
  inline void set_allocated_bind_key(::std::string* bind_key);

  // optional string bind_value = 10;
  inline bool has_bind_value() const;
  inline void clear_bind_value();
  static const int kBindValueFieldNumber = 10;
  inline const ::std::string& bind_value() const;
  inline void set_bind_value(const ::std::string& value);
  inline void set_bind_value(const char* value);
  inline void set_bind_value(const char* value, size_t size);
  inline ::std::string* mutable_bind_value();
  inline ::std::string* release_bind_value();
  inline void set_allocated_bind_value(::std::string* bind_value);

  // optional .caffe.DataParameter data_param = 25;
  inline bool has_data_param() const;
  inline void clear_data_param();
  static const int kDataParamFieldNumber = 25;
  inline const ::caffe::DataParameter& data_param() const;
  inline ::caffe::DataParameter* mutable_data_param();
  inline ::caffe::DataParameter* release_data_param();
  inline void set_allocated_data_param(::caffe::DataParameter* data_param);

  // optional .caffe.TransformationParameter transform_param = 26;
  inline bool has_transform_param() const;
  inline void clear_transform_param();
  static const int kTransformParamFieldNumber = 26;
  inline const ::caffe::TransformationParameter& transform_param() const;
  inline ::caffe::TransformationParameter* mutable_transform_param();
  inline ::caffe::TransformationParameter* release_transform_param();
  inline void set_allocated_transform_param(::caffe::TransformationParameter* transform_param);

  // optional .caffe.ConvolutionParameter convolution_param = 27;
  inline bool has_convolution_param() const;
  inline void clear_convolution_param();
  static const int kConvolutionParamFieldNumber = 27;
  inline const ::caffe::ConvolutionParameter& convolution_param() const;
  inline ::caffe::ConvolutionParameter* mutable_convolution_param();
  inline ::caffe::ConvolutionParameter* release_convolution_param();
  inline void set_allocated_convolution_param(::caffe::ConvolutionParameter* convolution_param);

  // optional .caffe.LossParameter loss_param = 28;
  inline bool has_loss_param() const;
  inline void clear_loss_param();
  static const int kLossParamFieldNumber = 28;
  inline const ::caffe::LossParameter& loss_param() const;
  inline ::caffe::LossParameter* mutable_loss_param();
  inline ::caffe::LossParameter* release_loss_param();
  inline void set_allocated_loss_param(::caffe::LossParameter* loss_param);

  // optional .caffe.PoolingParameter pooling_param = 29;
  inline bool has_pooling_param() const;
  inline void clear_pooling_param();
  static const int kPoolingParamFieldNumber = 29;
  inline const ::caffe::PoolingParameter& pooling_param() const;
  inline ::caffe::PoolingParameter* mutable_pooling_param();
  inline ::caffe::PoolingParameter* release_pooling_param();
  inline void set_allocated_pooling_param(::caffe::PoolingParameter* pooling_param);

  // optional .caffe.InnerProductParameter inner_product_param = 30;
  inline bool has_inner_product_param() const;
  inline void clear_inner_product_param();
  static const int kInnerProductParamFieldNumber = 30;
  inline const ::caffe::InnerProductParameter& inner_product_param() const;
  inline ::caffe::InnerProductParameter* mutable_inner_product_param();
  inline ::caffe::InnerProductParameter* release_inner_product_param();
  inline void set_allocated_inner_product_param(::caffe::InnerProductParameter* inner_product_param);

  // optional .caffe.BatchNormParameter batch_norm_param = 31;
  inline bool has_batch_norm_param() const;
  inline void clear_batch_norm_param();
  static const int kBatchNormParamFieldNumber = 31;
  inline const ::caffe::BatchNormParameter& batch_norm_param() const;
  inline ::caffe::BatchNormParameter* mutable_batch_norm_param();
  inline ::caffe::BatchNormParameter* release_batch_norm_param();
  inline void set_allocated_batch_norm_param(::caffe::BatchNormParameter* batch_norm_param);

  // optional .caffe.ShortcutParameter shortcut_param = 32;
  inline bool has_shortcut_param() const;
  inline void clear_shortcut_param();
  static const int kShortcutParamFieldNumber = 32;
  inline const ::caffe::ShortcutParameter& shortcut_param() const;
  inline ::caffe::ShortcutParameter* mutable_shortcut_param();
  inline ::caffe::ShortcutParameter* release_shortcut_param();
  inline void set_allocated_shortcut_param(::caffe::ShortcutParameter* shortcut_param);

  // optional .caffe.AccuracyParameter accuracy_param = 33;
  inline bool has_accuracy_param() const;
  inline void clear_accuracy_param();
  static const int kAccuracyParamFieldNumber = 33;
  inline const ::caffe::AccuracyParameter& accuracy_param() const;
  inline ::caffe::AccuracyParameter* mutable_accuracy_param();
  inline ::caffe::AccuracyParameter* release_accuracy_param();
  inline void set_allocated_accuracy_param(::caffe::AccuracyParameter* accuracy_param);

  // optional .caffe.NormalizeParameter norm_param = 34;
  inline bool has_norm_param() const;
  inline void clear_norm_param();
  static const int kNormParamFieldNumber = 34;
  inline const ::caffe::NormalizeParameter& norm_param() const;
  inline ::caffe::NormalizeParameter* mutable_norm_param();
  inline ::caffe::NormalizeParameter* release_norm_param();
  inline void set_allocated_norm_param(::caffe::NormalizeParameter* norm_param);

  // optional .caffe.ContextPoolingParameter context_pooling_param = 35;
  inline bool has_context_pooling_param() const;
  inline void clear_context_pooling_param();
  static const int kContextPoolingParamFieldNumber = 35;
  inline const ::caffe::ContextPoolingParameter& context_pooling_param() const;
  inline ::caffe::ContextPoolingParameter* mutable_context_pooling_param();
  inline ::caffe::ContextPoolingParameter* release_context_pooling_param();
  inline void set_allocated_context_pooling_param(::caffe::ContextPoolingParameter* context_pooling_param);

  // optional .caffe.CRFParameter crf_param = 36;
  inline bool has_crf_param() const;
  inline void clear_crf_param();
  static const int kCrfParamFieldNumber = 36;
  inline const ::caffe::CRFParameter& crf_param() const;
  inline ::caffe::CRFParameter* mutable_crf_param();
  inline ::caffe::CRFParameter* release_crf_param();
  inline void set_allocated_crf_param(::caffe::CRFParameter* crf_param);

  // optional .caffe.EltwiseParameter eltwise_param = 37;
  inline bool has_eltwise_param() const;
  inline void clear_eltwise_param();
  static const int kEltwiseParamFieldNumber = 37;
  inline const ::caffe::EltwiseParameter& eltwise_param() const;
  inline ::caffe::EltwiseParameter* mutable_eltwise_param();
  inline ::caffe::EltwiseParameter* release_eltwise_param();
  inline void set_allocated_eltwise_param(::caffe::EltwiseParameter* eltwise_param);

  // optional .caffe.ParseEvaluateParameter parse_evaluate_param = 38;
  inline bool has_parse_evaluate_param() const;
  inline void clear_parse_evaluate_param();
  static const int kParseEvaluateParamFieldNumber = 38;
  inline const ::caffe::ParseEvaluateParameter& parse_evaluate_param() const;
  inline ::caffe::ParseEvaluateParameter* mutable_parse_evaluate_param();
  inline ::caffe::ParseEvaluateParameter* release_parse_evaluate_param();
  inline void set_allocated_parse_evaluate_param(::caffe::ParseEvaluateParameter* parse_evaluate_param);

  // optional .caffe.DropoutParameter dropout_param = 39;
  inline bool has_dropout_param() const;
  inline void clear_dropout_param();
  static const int kDropoutParamFieldNumber = 39;
  inline const ::caffe::DropoutParameter& dropout_param() const;
  inline ::caffe::DropoutParameter* mutable_dropout_param();
  inline ::caffe::DropoutParameter* release_dropout_param();
  inline void set_allocated_dropout_param(::caffe::DropoutParameter* dropout_param);

  // optional .caffe.InterpParameter interp_param = 40;
  inline bool has_interp_param() const;
  inline void clear_interp_param();
  static const int kInterpParamFieldNumber = 40;
  inline const ::caffe::InterpParameter& interp_param() const;
  inline ::caffe::InterpParameter* mutable_interp_param();
  inline ::caffe::InterpParameter* release_interp_param();
  inline void set_allocated_interp_param(::caffe::InterpParameter* interp_param);

  // optional .caffe.SecParameter sec_param = 41;
  inline bool has_sec_param() const;
  inline void clear_sec_param();
  static const int kSecParamFieldNumber = 41;
  inline const ::caffe::SecParameter& sec_param() const;
  inline ::caffe::SecParameter* mutable_sec_param();
  inline ::caffe::SecParameter* release_sec_param();
  inline void set_allocated_sec_param(::caffe::SecParameter* sec_param);

  // optional .caffe.NoiseParameter noise_param = 42;
  inline bool has_noise_param() const;
  inline void clear_noise_param();
  static const int kNoiseParamFieldNumber = 42;
  inline const ::caffe::NoiseParameter& noise_param() const;
  inline ::caffe::NoiseParameter* mutable_noise_param();
  inline ::caffe::NoiseParameter* release_noise_param();
  inline void set_allocated_noise_param(::caffe::NoiseParameter* noise_param);

  // optional .caffe.ReLUParameter relu_param = 43;
  inline bool has_relu_param() const;
  inline void clear_relu_param();
  static const int kReluParamFieldNumber = 43;
  inline const ::caffe::ReLUParameter& relu_param() const;
  inline ::caffe::ReLUParameter* mutable_relu_param();
  inline ::caffe::ReLUParameter* release_relu_param();
  inline void set_allocated_relu_param(::caffe::ReLUParameter* relu_param);

  // optional .caffe.BlobShape shape_param = 44;
  inline bool has_shape_param() const;
  inline void clear_shape_param();
  static const int kShapeParamFieldNumber = 44;
  inline const ::caffe::BlobShape& shape_param() const;
  inline ::caffe::BlobShape* mutable_shape_param();
  inline ::caffe::BlobShape* release_shape_param();
  inline void set_allocated_shape_param(::caffe::BlobShape* shape_param);

  // optional .caffe.ConcatParameter concat_param = 45;
  inline bool has_concat_param() const;
  inline void clear_concat_param();
  static const int kConcatParamFieldNumber = 45;
  inline const ::caffe::ConcatParameter& concat_param() const;
  inline ::caffe::ConcatParameter* mutable_concat_param();
  inline ::caffe::ConcatParameter* release_concat_param();
  inline void set_allocated_concat_param(::caffe::ConcatParameter* concat_param);

  // repeated .caffe.BlobProto first_moment = 46;
  inline int first_moment_size() const;
  inline void clear_first_moment();
  static const int kFirstMomentFieldNumber = 46;
  inline const ::caffe::BlobProto& first_moment(int index) const;
  inline ::caffe::BlobProto* mutable_first_moment(int index);
  inline ::caffe::BlobProto* add_first_moment();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >&
      first_moment() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >*
      mutable_first_moment();

  // repeated .caffe.BlobProto second_moment = 47;
  inline int second_moment_size() const;
  inline void clear_second_moment();
  static const int kSecondMomentFieldNumber = 47;
  inline const ::caffe::BlobProto& second_moment(int index) const;
  inline ::caffe::BlobProto* mutable_second_moment(int index);
  inline ::caffe::BlobProto* add_second_moment();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >&
      second_moment() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >*
      mutable_second_moment();

  // repeated int32 bottom_index = 48;
  inline int bottom_index_size() const;
  inline void clear_bottom_index();
  static const int kBottomIndexFieldNumber = 48;
  inline ::google::protobuf::int32 bottom_index(int index) const;
  inline void set_bottom_index(int index, ::google::protobuf::int32 value);
  inline void add_bottom_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bottom_index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bottom_index();

  // @@protoc_insertion_point(class_scope:caffe.LayerParameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_include();
  inline void clear_has_include();
  inline void set_has_bind_key();
  inline void clear_has_bind_key();
  inline void set_has_bind_value();
  inline void clear_has_bind_value();
  inline void set_has_data_param();
  inline void clear_has_data_param();
  inline void set_has_transform_param();
  inline void clear_has_transform_param();
  inline void set_has_convolution_param();
  inline void clear_has_convolution_param();
  inline void set_has_loss_param();
  inline void clear_has_loss_param();
  inline void set_has_pooling_param();
  inline void clear_has_pooling_param();
  inline void set_has_inner_product_param();
  inline void clear_has_inner_product_param();
  inline void set_has_batch_norm_param();
  inline void clear_has_batch_norm_param();
  inline void set_has_shortcut_param();
  inline void clear_has_shortcut_param();
  inline void set_has_accuracy_param();
  inline void clear_has_accuracy_param();
  inline void set_has_norm_param();
  inline void clear_has_norm_param();
  inline void set_has_context_pooling_param();
  inline void clear_has_context_pooling_param();
  inline void set_has_crf_param();
  inline void clear_has_crf_param();
  inline void set_has_eltwise_param();
  inline void clear_has_eltwise_param();
  inline void set_has_parse_evaluate_param();
  inline void clear_has_parse_evaluate_param();
  inline void set_has_dropout_param();
  inline void clear_has_dropout_param();
  inline void set_has_interp_param();
  inline void clear_has_interp_param();
  inline void set_has_sec_param();
  inline void clear_has_sec_param();
  inline void set_has_noise_param();
  inline void clear_has_noise_param();
  inline void set_has_relu_param();
  inline void clear_has_relu_param();
  inline void set_has_shape_param();
  inline void clear_has_shape_param();
  inline void set_has_concat_param();
  inline void clear_has_concat_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bottom_;
  ::google::protobuf::RepeatedPtrField< ::std::string> top_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bottom_flow_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > top_flow_;
  ::caffe::LayerProp* include_;
  ::google::protobuf::RepeatedPtrField< ::caffe::ParamSpec > param_;
  ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto > blobs_;
  ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter > branch_;
  ::std::string* bind_key_;
  ::std::string* bind_value_;
  ::caffe::DataParameter* data_param_;
  ::caffe::TransformationParameter* transform_param_;
  ::caffe::ConvolutionParameter* convolution_param_;
  ::caffe::LossParameter* loss_param_;
  ::caffe::PoolingParameter* pooling_param_;
  ::caffe::InnerProductParameter* inner_product_param_;
  ::caffe::BatchNormParameter* batch_norm_param_;
  ::caffe::ShortcutParameter* shortcut_param_;
  ::caffe::AccuracyParameter* accuracy_param_;
  ::caffe::NormalizeParameter* norm_param_;
  ::caffe::ContextPoolingParameter* context_pooling_param_;
  ::caffe::CRFParameter* crf_param_;
  ::caffe::EltwiseParameter* eltwise_param_;
  ::caffe::ParseEvaluateParameter* parse_evaluate_param_;
  ::caffe::DropoutParameter* dropout_param_;
  ::caffe::InterpParameter* interp_param_;
  ::caffe::SecParameter* sec_param_;
  ::caffe::NoiseParameter* noise_param_;
  ::caffe::ReLUParameter* relu_param_;
  ::caffe::BlobShape* shape_param_;
  ::caffe::ConcatParameter* concat_param_;
  ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto > first_moment_;
  ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto > second_moment_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bottom_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(36 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static LayerParameter* default_instance_;
};
// -------------------------------------------------------------------

class ConcatParameter : public ::google::protobuf::Message {
 public:
  ConcatParameter();
  virtual ~ConcatParameter();

  ConcatParameter(const ConcatParameter& from);

  inline ConcatParameter& operator=(const ConcatParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConcatParameter& default_instance();

  void Swap(ConcatParameter* other);

  // implements Message ----------------------------------------------

  ConcatParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConcatParameter& from);
  void MergeFrom(const ConcatParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 channels = 1;
  inline int channels_size() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 1;
  inline ::google::protobuf::int32 channels(int index) const;
  inline void set_channels(int index, ::google::protobuf::int32 value);
  inline void add_channels(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      channels() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:caffe.ConcatParameter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > channels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static ConcatParameter* default_instance_;
};
// -------------------------------------------------------------------

class ReLUParameter : public ::google::protobuf::Message {
 public:
  ReLUParameter();
  virtual ~ReLUParameter();

  ReLUParameter(const ReLUParameter& from);

  inline ReLUParameter& operator=(const ReLUParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReLUParameter& default_instance();

  void Swap(ReLUParameter* other);

  // implements Message ----------------------------------------------

  ReLUParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReLUParameter& from);
  void MergeFrom(const ReLUParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float negative_slope = 1 [default = 0];
  inline bool has_negative_slope() const;
  inline void clear_negative_slope();
  static const int kNegativeSlopeFieldNumber = 1;
  inline float negative_slope() const;
  inline void set_negative_slope(float value);

  // @@protoc_insertion_point(class_scope:caffe.ReLUParameter)
 private:
  inline void set_has_negative_slope();
  inline void clear_has_negative_slope();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float negative_slope_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static ReLUParameter* default_instance_;
};
// -------------------------------------------------------------------

class NoiseParameter : public ::google::protobuf::Message {
 public:
  NoiseParameter();
  virtual ~NoiseParameter();

  NoiseParameter(const NoiseParameter& from);

  inline NoiseParameter& operator=(const NoiseParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoiseParameter& default_instance();

  void Swap(NoiseParameter* other);

  // implements Message ----------------------------------------------

  NoiseParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoiseParameter& from);
  void MergeFrom(const NoiseParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 channels = 2;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 2;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 classes = 3;
  inline bool has_classes() const;
  inline void clear_classes();
  static const int kClassesFieldNumber = 3;
  inline ::google::protobuf::int32 classes() const;
  inline void set_classes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe.NoiseParameter)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_classes();
  inline void clear_has_classes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 classes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static NoiseParameter* default_instance_;
};
// -------------------------------------------------------------------

class SecParameter : public ::google::protobuf::Message {
 public:
  SecParameter();
  virtual ~SecParameter();

  SecParameter(const SecParameter& from);

  inline SecParameter& operator=(const SecParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecParameter& default_instance();

  void Swap(SecParameter* other);

  // implements Message ----------------------------------------------

  SecParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecParameter& from);
  void MergeFrom(const SecParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sec_feature = 1;
  inline bool has_sec_feature() const;
  inline void clear_sec_feature();
  static const int kSecFeatureFieldNumber = 1;
  inline const ::std::string& sec_feature() const;
  inline void set_sec_feature(const ::std::string& value);
  inline void set_sec_feature(const char* value);
  inline void set_sec_feature(const char* value, size_t size);
  inline ::std::string* mutable_sec_feature();
  inline ::std::string* release_sec_feature();
  inline void set_allocated_sec_feature(::std::string* sec_feature);

  // @@protoc_insertion_point(class_scope:caffe.SecParameter)
 private:
  inline void set_has_sec_feature();
  inline void clear_has_sec_feature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sec_feature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static SecParameter* default_instance_;
};
// -------------------------------------------------------------------

class InterpParameter : public ::google::protobuf::Message {
 public:
  InterpParameter();
  virtual ~InterpParameter();

  InterpParameter(const InterpParameter& from);

  inline InterpParameter& operator=(const InterpParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterpParameter& default_instance();

  void Swap(InterpParameter* other);

  // implements Message ----------------------------------------------

  InterpParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterpParameter& from);
  void MergeFrom(const InterpParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float interp_ratio = 1;
  inline bool has_interp_ratio() const;
  inline void clear_interp_ratio();
  static const int kInterpRatioFieldNumber = 1;
  inline float interp_ratio() const;
  inline void set_interp_ratio(float value);

  // optional int32 stride = 2;
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 2;
  inline ::google::protobuf::int32 stride() const;
  inline void set_stride(::google::protobuf::int32 value);

  // optional int32 kernel_size = 3;
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 3;
  inline ::google::protobuf::int32 kernel_size() const;
  inline void set_kernel_size(::google::protobuf::int32 value);

  // optional int32 num_classes = 4;
  inline bool has_num_classes() const;
  inline void clear_num_classes();
  static const int kNumClassesFieldNumber = 4;
  inline ::google::protobuf::int32 num_classes() const;
  inline void set_num_classes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe.InterpParameter)
 private:
  inline void set_has_interp_ratio();
  inline void clear_has_interp_ratio();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_num_classes();
  inline void clear_has_num_classes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float interp_ratio_;
  ::google::protobuf::int32 stride_;
  ::google::protobuf::int32 kernel_size_;
  ::google::protobuf::int32 num_classes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static InterpParameter* default_instance_;
};
// -------------------------------------------------------------------

class DropoutParameter : public ::google::protobuf::Message {
 public:
  DropoutParameter();
  virtual ~DropoutParameter();

  DropoutParameter(const DropoutParameter& from);

  inline DropoutParameter& operator=(const DropoutParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropoutParameter& default_instance();

  void Swap(DropoutParameter* other);

  // implements Message ----------------------------------------------

  DropoutParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropoutParameter& from);
  void MergeFrom(const DropoutParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float dropout_ratio = 1 [default = 0.5];
  inline bool has_dropout_ratio() const;
  inline void clear_dropout_ratio();
  static const int kDropoutRatioFieldNumber = 1;
  inline float dropout_ratio() const;
  inline void set_dropout_ratio(float value);

  // @@protoc_insertion_point(class_scope:caffe.DropoutParameter)
 private:
  inline void set_has_dropout_ratio();
  inline void clear_has_dropout_ratio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float dropout_ratio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static DropoutParameter* default_instance_;
};
// -------------------------------------------------------------------

class ParseEvaluateParameter : public ::google::protobuf::Message {
 public:
  ParseEvaluateParameter();
  virtual ~ParseEvaluateParameter();

  ParseEvaluateParameter(const ParseEvaluateParameter& from);

  inline ParseEvaluateParameter& operator=(const ParseEvaluateParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParseEvaluateParameter& default_instance();

  void Swap(ParseEvaluateParameter* other);

  // implements Message ----------------------------------------------

  ParseEvaluateParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParseEvaluateParameter& from);
  void MergeFrom(const ParseEvaluateParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 num_labels = 1;
  inline bool has_num_labels() const;
  inline void clear_num_labels();
  static const int kNumLabelsFieldNumber = 1;
  inline ::google::protobuf::int32 num_labels() const;
  inline void set_num_labels(::google::protobuf::int32 value);

  // repeated int32 ignore_label = 2;
  inline int ignore_label_size() const;
  inline void clear_ignore_label();
  static const int kIgnoreLabelFieldNumber = 2;
  inline ::google::protobuf::int32 ignore_label(int index) const;
  inline void set_ignore_label(int index, ::google::protobuf::int32 value);
  inline void add_ignore_label(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ignore_label() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ignore_label();

  // @@protoc_insertion_point(class_scope:caffe.ParseEvaluateParameter)
 private:
  inline void set_has_num_labels();
  inline void clear_has_num_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ignore_label_;
  ::google::protobuf::int32 num_labels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static ParseEvaluateParameter* default_instance_;
};
// -------------------------------------------------------------------

class EltwiseParameter : public ::google::protobuf::Message {
 public:
  EltwiseParameter();
  virtual ~EltwiseParameter();

  EltwiseParameter(const EltwiseParameter& from);

  inline EltwiseParameter& operator=(const EltwiseParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EltwiseParameter& default_instance();

  void Swap(EltwiseParameter* other);

  // implements Message ----------------------------------------------

  EltwiseParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EltwiseParameter& from);
  void MergeFrom(const EltwiseParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string operation = 1 [default = "sum"];
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 1;
  inline const ::std::string& operation() const;
  inline void set_operation(const ::std::string& value);
  inline void set_operation(const char* value);
  inline void set_operation(const char* value, size_t size);
  inline ::std::string* mutable_operation();
  inline ::std::string* release_operation();
  inline void set_allocated_operation(::std::string* operation);

  // repeated float coeff = 2;
  inline int coeff_size() const;
  inline void clear_coeff();
  static const int kCoeffFieldNumber = 2;
  inline float coeff(int index) const;
  inline void set_coeff(int index, float value);
  inline void add_coeff(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      coeff() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_coeff();

  // optional bool stable_prod_grad = 3 [default = true];
  inline bool has_stable_prod_grad() const;
  inline void clear_stable_prod_grad();
  static const int kStableProdGradFieldNumber = 3;
  inline bool stable_prod_grad() const;
  inline void set_stable_prod_grad(bool value);

  // repeated bool backward = 4;
  inline int backward_size() const;
  inline void clear_backward();
  static const int kBackwardFieldNumber = 4;
  inline bool backward(int index) const;
  inline void set_backward(int index, bool value);
  inline void add_backward(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      backward() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_backward();

  // @@protoc_insertion_point(class_scope:caffe.EltwiseParameter)
 private:
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_stable_prod_grad();
  inline void clear_has_stable_prod_grad();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* operation_;
  static ::std::string* _default_operation_;
  ::google::protobuf::RepeatedField< float > coeff_;
  ::google::protobuf::RepeatedField< bool > backward_;
  bool stable_prod_grad_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static EltwiseParameter* default_instance_;
};
// -------------------------------------------------------------------

class CRFParameter : public ::google::protobuf::Message {
 public:
  CRFParameter();
  virtual ~CRFParameter();

  CRFParameter(const CRFParameter& from);

  inline CRFParameter& operator=(const CRFParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRFParameter& default_instance();

  void Swap(CRFParameter* other);

  // implements Message ----------------------------------------------

  CRFParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRFParameter& from);
  void MergeFrom(const CRFParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 max_iter = 1 [default = 1];
  inline bool has_max_iter() const;
  inline void clear_max_iter();
  static const int kMaxIterFieldNumber = 1;
  inline ::google::protobuf::int32 max_iter() const;
  inline void set_max_iter(::google::protobuf::int32 value);

  // optional float radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline float radius() const;
  inline void set_radius(float value);

  // optional float scale = 3 [default = 0.01];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 3;
  inline float scale() const;
  inline void set_scale(float value);

  // optional float eps = 4 [default = 0.01];
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 4;
  inline float eps() const;
  inline void set_eps(float value);

  // optional float alpha = 5 [default = 0.01];
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 5;
  inline float alpha() const;
  inline void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:caffe.CRFParameter)
 private:
  inline void set_has_max_iter();
  inline void clear_has_max_iter();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_eps();
  inline void clear_has_eps();
  inline void set_has_alpha();
  inline void clear_has_alpha();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 max_iter_;
  float radius_;
  float scale_;
  float eps_;
  float alpha_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static CRFParameter* default_instance_;
};
// -------------------------------------------------------------------

class ContextPoolingParameter : public ::google::protobuf::Message {
 public:
  ContextPoolingParameter();
  virtual ~ContextPoolingParameter();

  ContextPoolingParameter(const ContextPoolingParameter& from);

  inline ContextPoolingParameter& operator=(const ContextPoolingParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContextPoolingParameter& default_instance();

  void Swap(ContextPoolingParameter* other);

  // implements Message ----------------------------------------------

  ContextPoolingParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContextPoolingParameter& from);
  void MergeFrom(const ContextPoolingParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 context_h = 1 [default = 0];
  inline bool has_context_h() const;
  inline void clear_context_h();
  static const int kContextHFieldNumber = 1;
  inline ::google::protobuf::uint32 context_h() const;
  inline void set_context_h(::google::protobuf::uint32 value);

  // optional uint32 context_w = 2 [default = 0];
  inline bool has_context_w() const;
  inline void clear_context_w();
  static const int kContextWFieldNumber = 2;
  inline ::google::protobuf::uint32 context_w() const;
  inline void set_context_w(::google::protobuf::uint32 value);

  // optional string pool = 3;
  inline bool has_pool() const;
  inline void clear_pool();
  static const int kPoolFieldNumber = 3;
  inline const ::std::string& pool() const;
  inline void set_pool(const ::std::string& value);
  inline void set_pool(const char* value);
  inline void set_pool(const char* value, size_t size);
  inline ::std::string* mutable_pool();
  inline ::std::string* release_pool();
  inline void set_allocated_pool(::std::string* pool);

  // optional string mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline const ::std::string& mode() const;
  inline void set_mode(const ::std::string& value);
  inline void set_mode(const char* value);
  inline void set_mode(const char* value, size_t size);
  inline ::std::string* mutable_mode();
  inline ::std::string* release_mode();
  inline void set_allocated_mode(::std::string* mode);

  // @@protoc_insertion_point(class_scope:caffe.ContextPoolingParameter)
 private:
  inline void set_has_context_h();
  inline void clear_has_context_h();
  inline void set_has_context_w();
  inline void clear_has_context_w();
  inline void set_has_pool();
  inline void clear_has_pool();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 context_h_;
  ::google::protobuf::uint32 context_w_;
  ::std::string* pool_;
  ::std::string* mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static ContextPoolingParameter* default_instance_;
};
// -------------------------------------------------------------------

class NormalizeParameter : public ::google::protobuf::Message {
 public:
  NormalizeParameter();
  virtual ~NormalizeParameter();

  NormalizeParameter(const NormalizeParameter& from);

  inline NormalizeParameter& operator=(const NormalizeParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalizeParameter& default_instance();

  void Swap(NormalizeParameter* other);

  // implements Message ----------------------------------------------

  NormalizeParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NormalizeParameter& from);
  void MergeFrom(const NormalizeParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float scale_value = 1 [default = 1];
  inline bool has_scale_value() const;
  inline void clear_scale_value();
  static const int kScaleValueFieldNumber = 1;
  inline float scale_value() const;
  inline void set_scale_value(float value);

  // optional float eps = 2 [default = 1e-10];
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 2;
  inline float eps() const;
  inline void set_eps(float value);

  // @@protoc_insertion_point(class_scope:caffe.NormalizeParameter)
 private:
  inline void set_has_scale_value();
  inline void clear_has_scale_value();
  inline void set_has_eps();
  inline void clear_has_eps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float scale_value_;
  float eps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static NormalizeParameter* default_instance_;
};
// -------------------------------------------------------------------

class AccuracyParameter : public ::google::protobuf::Message {
 public:
  AccuracyParameter();
  virtual ~AccuracyParameter();

  AccuracyParameter(const AccuracyParameter& from);

  inline AccuracyParameter& operator=(const AccuracyParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccuracyParameter& default_instance();

  void Swap(AccuracyParameter* other);

  // implements Message ----------------------------------------------

  AccuracyParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccuracyParameter& from);
  void MergeFrom(const AccuracyParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 top_k = 1 [default = 1];
  inline bool has_top_k() const;
  inline void clear_top_k();
  static const int kTopKFieldNumber = 1;
  inline ::google::protobuf::uint32 top_k() const;
  inline void set_top_k(::google::protobuf::uint32 value);

  // optional int32 ignore_label = 2;
  inline bool has_ignore_label() const;
  inline void clear_ignore_label();
  static const int kIgnoreLabelFieldNumber = 2;
  inline ::google::protobuf::int32 ignore_label() const;
  inline void set_ignore_label(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe.AccuracyParameter)
 private:
  inline void set_has_top_k();
  inline void clear_has_top_k();
  inline void set_has_ignore_label();
  inline void clear_has_ignore_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 top_k_;
  ::google::protobuf::int32 ignore_label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static AccuracyParameter* default_instance_;
};
// -------------------------------------------------------------------

class ShortcutParameter : public ::google::protobuf::Message {
 public:
  ShortcutParameter();
  virtual ~ShortcutParameter();

  ShortcutParameter(const ShortcutParameter& from);

  inline ShortcutParameter& operator=(const ShortcutParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShortcutParameter& default_instance();

  void Swap(ShortcutParameter* other);

  // implements Message ----------------------------------------------

  ShortcutParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShortcutParameter& from);
  void MergeFrom(const ShortcutParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float scale = 1;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 1;
  inline float scale() const;
  inline void set_scale(float value);

  // optional float dropout_ratio = 2 [default = 0.5];
  inline bool has_dropout_ratio() const;
  inline void clear_dropout_ratio();
  static const int kDropoutRatioFieldNumber = 2;
  inline float dropout_ratio() const;
  inline void set_dropout_ratio(float value);

  // optional uint32 groups = 3 [default = 1];
  inline bool has_groups() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 3;
  inline ::google::protobuf::uint32 groups() const;
  inline void set_groups(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:caffe.ShortcutParameter)
 private:
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_dropout_ratio();
  inline void clear_has_dropout_ratio();
  inline void set_has_groups();
  inline void clear_has_groups();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float scale_;
  float dropout_ratio_;
  ::google::protobuf::uint32 groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static ShortcutParameter* default_instance_;
};
// -------------------------------------------------------------------

class BatchNormParameter : public ::google::protobuf::Message {
 public:
  BatchNormParameter();
  virtual ~BatchNormParameter();

  BatchNormParameter(const BatchNormParameter& from);

  inline BatchNormParameter& operator=(const BatchNormParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchNormParameter& default_instance();

  void Swap(BatchNormParameter* other);

  // implements Message ----------------------------------------------

  BatchNormParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchNormParameter& from);
  void MergeFrom(const BatchNormParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bn_state = 1 [default = "learned"];
  inline bool has_bn_state() const;
  inline void clear_bn_state();
  static const int kBnStateFieldNumber = 1;
  inline const ::std::string& bn_state() const;
  inline void set_bn_state(const ::std::string& value);
  inline void set_bn_state(const char* value);
  inline void set_bn_state(const char* value, size_t size);
  inline ::std::string* mutable_bn_state();
  inline ::std::string* release_bn_state();
  inline void set_allocated_bn_state(::std::string* bn_state);

  // @@protoc_insertion_point(class_scope:caffe.BatchNormParameter)
 private:
  inline void set_has_bn_state();
  inline void clear_has_bn_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bn_state_;
  static ::std::string* _default_bn_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static BatchNormParameter* default_instance_;
};
// -------------------------------------------------------------------

class InputBlob : public ::google::protobuf::Message {
 public:
  InputBlob();
  virtual ~InputBlob();

  InputBlob(const InputBlob& from);

  inline InputBlob& operator=(const InputBlob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputBlob& default_instance();

  void Swap(InputBlob* other);

  // implements Message ----------------------------------------------

  InputBlob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputBlob& from);
  void MergeFrom(const InputBlob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 channels = 3;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 3;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 width = 5;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 5;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe.InputBlob)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static InputBlob* default_instance_;
};
// -------------------------------------------------------------------

class NetParameter : public ::google::protobuf::Message {
 public:
  NetParameter();
  virtual ~NetParameter();

  NetParameter(const NetParameter& from);

  inline NetParameter& operator=(const NetParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetParameter& default_instance();

  void Swap(NetParameter* other);

  // implements Message ----------------------------------------------

  NetParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetParameter& from);
  void MergeFrom(const NetParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .caffe.LayerParameter layer = 100;
  inline int layer_size() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 100;
  inline const ::caffe::LayerParameter& layer(int index) const;
  inline ::caffe::LayerParameter* mutable_layer(int index);
  inline ::caffe::LayerParameter* add_layer();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >&
      layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >*
      mutable_layer();

  // repeated string input = 3;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 3;
  inline const ::std::string& input(int index) const;
  inline ::std::string* mutable_input(int index);
  inline void set_input(int index, const ::std::string& value);
  inline void set_input(int index, const char* value);
  inline void set_input(int index, const char* value, size_t size);
  inline ::std::string* add_input();
  inline void add_input(const ::std::string& value);
  inline void add_input(const char* value);
  inline void add_input(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // repeated .caffe.InputBlob input_blob = 5;
  inline int input_blob_size() const;
  inline void clear_input_blob();
  static const int kInputBlobFieldNumber = 5;
  inline const ::caffe::InputBlob& input_blob(int index) const;
  inline ::caffe::InputBlob* mutable_input_blob(int index);
  inline ::caffe::InputBlob* add_input_blob();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe::InputBlob >&
      input_blob() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe::InputBlob >*
      mutable_input_blob();

  // optional int32 num_flow = 6 [default = 0];
  inline bool has_num_flow() const;
  inline void clear_num_flow();
  static const int kNumFlowFieldNumber = 6;
  inline ::google::protobuf::int32 num_flow() const;
  inline void set_num_flow(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe.NetParameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_num_flow();
  inline void clear_has_num_flow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter > layer_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::RepeatedPtrField< ::caffe::InputBlob > input_blob_;
  ::google::protobuf::int32 num_flow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static NetParameter* default_instance_;
};
// -------------------------------------------------------------------

class NetOptimizer : public ::google::protobuf::Message {
 public:
  NetOptimizer();
  virtual ~NetOptimizer();

  NetOptimizer(const NetOptimizer& from);

  inline NetOptimizer& operator=(const NetOptimizer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetOptimizer& default_instance();

  void Swap(NetOptimizer* other);

  // implements Message ----------------------------------------------

  NetOptimizer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetOptimizer& from);
  void MergeFrom(const NetOptimizer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float base_lr = 1;
  inline bool has_base_lr() const;
  inline void clear_base_lr();
  static const int kBaseLrFieldNumber = 1;
  inline float base_lr() const;
  inline void set_base_lr(float value);

  // optional string type = 2 [default = "SGD"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string lr_policy = 3;
  inline bool has_lr_policy() const;
  inline void clear_lr_policy();
  static const int kLrPolicyFieldNumber = 3;
  inline const ::std::string& lr_policy() const;
  inline void set_lr_policy(const ::std::string& value);
  inline void set_lr_policy(const char* value);
  inline void set_lr_policy(const char* value, size_t size);
  inline ::std::string* mutable_lr_policy();
  inline ::std::string* release_lr_policy();
  inline void set_allocated_lr_policy(::std::string* lr_policy);

  // optional float gamma = 4;
  inline bool has_gamma() const;
  inline void clear_gamma();
  static const int kGammaFieldNumber = 4;
  inline float gamma() const;
  inline void set_gamma(float value);

  // optional float power = 5;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 5;
  inline float power() const;
  inline void set_power(float value);

  // optional int32 stepsize = 6;
  inline bool has_stepsize() const;
  inline void clear_stepsize();
  static const int kStepsizeFieldNumber = 6;
  inline ::google::protobuf::int32 stepsize() const;
  inline void set_stepsize(::google::protobuf::int32 value);

  // repeated int32 stepvalue = 7;
  inline int stepvalue_size() const;
  inline void clear_stepvalue();
  static const int kStepvalueFieldNumber = 7;
  inline ::google::protobuf::int32 stepvalue(int index) const;
  inline void set_stepvalue(int index, ::google::protobuf::int32 value);
  inline void add_stepvalue(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      stepvalue() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_stepvalue();

  // optional float momentum = 8 [default = 0.9];
  inline bool has_momentum() const;
  inline void clear_momentum();
  static const int kMomentumFieldNumber = 8;
  inline float momentum() const;
  inline void set_momentum(float value);

  // optional float weight_decay = 9;
  inline bool has_weight_decay() const;
  inline void clear_weight_decay();
  static const int kWeightDecayFieldNumber = 9;
  inline float weight_decay() const;
  inline void set_weight_decay(float value);

  // optional int32 display = 11;
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 11;
  inline ::google::protobuf::int32 display() const;
  inline void set_display(::google::protobuf::int32 value);

  // optional int32 average_loss = 12 [default = 1];
  inline bool has_average_loss() const;
  inline void clear_average_loss();
  static const int kAverageLossFieldNumber = 12;
  inline ::google::protobuf::int32 average_loss() const;
  inline void set_average_loss(::google::protobuf::int32 value);

  // optional float momentum2 = 13 [default = 0.999];
  inline bool has_momentum2() const;
  inline void clear_momentum2();
  static const int kMomentum2FieldNumber = 13;
  inline float momentum2() const;
  inline void set_momentum2(float value);

  // optional float delta = 14 [default = 1e-08];
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 14;
  inline float delta() const;
  inline void set_delta(float value);

  // @@protoc_insertion_point(class_scope:caffe.NetOptimizer)
 private:
  inline void set_has_base_lr();
  inline void clear_has_base_lr();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_lr_policy();
  inline void clear_has_lr_policy();
  inline void set_has_gamma();
  inline void clear_has_gamma();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_stepsize();
  inline void clear_has_stepsize();
  inline void set_has_momentum();
  inline void clear_has_momentum();
  inline void set_has_weight_decay();
  inline void clear_has_weight_decay();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_average_loss();
  inline void clear_has_average_loss();
  inline void set_has_momentum2();
  inline void clear_has_momentum2();
  inline void set_has_delta();
  inline void clear_has_delta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  static ::std::string* _default_type_;
  float base_lr_;
  float gamma_;
  ::std::string* lr_policy_;
  float power_;
  ::google::protobuf::int32 stepsize_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > stepvalue_;
  float momentum_;
  float weight_decay_;
  ::google::protobuf::int32 display_;
  ::google::protobuf::int32 average_loss_;
  float momentum2_;
  float delta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static NetOptimizer* default_instance_;
};
// -------------------------------------------------------------------

class SolverState : public ::google::protobuf::Message {
 public:
  SolverState();
  virtual ~SolverState();

  SolverState(const SolverState& from);

  inline SolverState& operator=(const SolverState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverState& default_instance();

  void Swap(SolverState* other);

  // implements Message ----------------------------------------------

  SolverState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolverState& from);
  void MergeFrom(const SolverState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 iter = 1;
  inline bool has_iter() const;
  inline void clear_iter();
  static const int kIterFieldNumber = 1;
  inline ::google::protobuf::int32 iter() const;
  inline void set_iter(::google::protobuf::int32 value);

  // optional string learned_net = 2;
  inline bool has_learned_net() const;
  inline void clear_learned_net();
  static const int kLearnedNetFieldNumber = 2;
  inline const ::std::string& learned_net() const;
  inline void set_learned_net(const ::std::string& value);
  inline void set_learned_net(const char* value);
  inline void set_learned_net(const char* value, size_t size);
  inline ::std::string* mutable_learned_net();
  inline ::std::string* release_learned_net();
  inline void set_allocated_learned_net(::std::string* learned_net);

  // optional .caffe.NetState net_state = 3;
  inline bool has_net_state() const;
  inline void clear_net_state();
  static const int kNetStateFieldNumber = 3;
  inline const ::caffe::NetState& net_state() const;
  inline ::caffe::NetState* mutable_net_state();
  inline ::caffe::NetState* release_net_state();
  inline void set_allocated_net_state(::caffe::NetState* net_state);

  // optional string d_state_file = 4;
  inline bool has_d_state_file() const;
  inline void clear_d_state_file();
  static const int kDStateFileFieldNumber = 4;
  inline const ::std::string& d_state_file() const;
  inline void set_d_state_file(const ::std::string& value);
  inline void set_d_state_file(const char* value);
  inline void set_d_state_file(const char* value, size_t size);
  inline ::std::string* mutable_d_state_file();
  inline ::std::string* release_d_state_file();
  inline void set_allocated_d_state_file(::std::string* d_state_file);

  // optional string g_state_file = 5;
  inline bool has_g_state_file() const;
  inline void clear_g_state_file();
  static const int kGStateFileFieldNumber = 5;
  inline const ::std::string& g_state_file() const;
  inline void set_g_state_file(const ::std::string& value);
  inline void set_g_state_file(const char* value);
  inline void set_g_state_file(const char* value, size_t size);
  inline ::std::string* mutable_g_state_file();
  inline ::std::string* release_g_state_file();
  inline void set_allocated_g_state_file(::std::string* g_state_file);

  // @@protoc_insertion_point(class_scope:caffe.SolverState)
 private:
  inline void set_has_iter();
  inline void clear_has_iter();
  inline void set_has_learned_net();
  inline void clear_has_learned_net();
  inline void set_has_net_state();
  inline void clear_has_net_state();
  inline void set_has_d_state_file();
  inline void clear_has_d_state_file();
  inline void set_has_g_state_file();
  inline void clear_has_g_state_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* learned_net_;
  ::caffe::NetState* net_state_;
  ::std::string* d_state_file_;
  ::std::string* g_state_file_;
  ::google::protobuf::int32 iter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static SolverState* default_instance_;
};
// -------------------------------------------------------------------

class NetState : public ::google::protobuf::Message {
 public:
  NetState();
  virtual ~NetState();

  NetState(const NetState& from);

  inline NetState& operator=(const NetState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetState& default_instance();

  void Swap(NetState* other);

  // implements Message ----------------------------------------------

  NetState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetState& from);
  void MergeFrom(const NetState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe.LayerParameter layer = 1;
  inline int layer_size() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline const ::caffe::LayerParameter& layer(int index) const;
  inline ::caffe::LayerParameter* mutable_layer(int index);
  inline ::caffe::LayerParameter* add_layer();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >&
      layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >*
      mutable_layer();

  // optional int32 adam_iter = 2;
  inline bool has_adam_iter() const;
  inline void clear_adam_iter();
  static const int kAdamIterFieldNumber = 2;
  inline ::google::protobuf::int32 adam_iter() const;
  inline void set_adam_iter(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:caffe.NetState)
 private:
  inline void set_has_adam_iter();
  inline void clear_has_adam_iter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter > layer_;
  ::google::protobuf::int32 adam_iter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static NetState* default_instance_;
};
// -------------------------------------------------------------------

class SolverParameter : public ::google::protobuf::Message {
 public:
  SolverParameter();
  virtual ~SolverParameter();

  SolverParameter(const SolverParameter& from);

  inline SolverParameter& operator=(const SolverParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverParameter& default_instance();

  void Swap(SolverParameter* other);

  // implements Message ----------------------------------------------

  SolverParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolverParameter& from);
  void MergeFrom(const SolverParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string net = 1;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 1;
  inline const ::std::string& net() const;
  inline void set_net(const ::std::string& value);
  inline void set_net(const char* value);
  inline void set_net(const char* value, size_t size);
  inline ::std::string* mutable_net();
  inline ::std::string* release_net();
  inline void set_allocated_net(::std::string* net);

  // optional .caffe.NetParameter net_param = 2;
  inline bool has_net_param() const;
  inline void clear_net_param();
  static const int kNetParamFieldNumber = 2;
  inline const ::caffe::NetParameter& net_param() const;
  inline ::caffe::NetParameter* mutable_net_param();
  inline ::caffe::NetParameter* release_net_param();
  inline void set_allocated_net_param(::caffe::NetParameter* net_param);

  // optional .caffe.NetOptimizer net_opt = 3;
  inline bool has_net_opt() const;
  inline void clear_net_opt();
  static const int kNetOptFieldNumber = 3;
  inline const ::caffe::NetOptimizer& net_opt() const;
  inline ::caffe::NetOptimizer* mutable_net_opt();
  inline ::caffe::NetOptimizer* release_net_opt();
  inline void set_allocated_net_opt(::caffe::NetOptimizer* net_opt);

  // optional int32 max_iter = 4;
  inline bool has_max_iter() const;
  inline void clear_max_iter();
  static const int kMaxIterFieldNumber = 4;
  inline ::google::protobuf::int32 max_iter() const;
  inline void set_max_iter(::google::protobuf::int32 value);

  // optional bool test_initialization = 5;
  inline bool has_test_initialization() const;
  inline void clear_test_initialization();
  static const int kTestInitializationFieldNumber = 5;
  inline bool test_initialization() const;
  inline void set_test_initialization(bool value);

  // optional int32 test_interval = 6;
  inline bool has_test_interval() const;
  inline void clear_test_interval();
  static const int kTestIntervalFieldNumber = 6;
  inline ::google::protobuf::int32 test_interval() const;
  inline void set_test_interval(::google::protobuf::int32 value);

  // optional int32 test_iter = 7;
  inline bool has_test_iter() const;
  inline void clear_test_iter();
  static const int kTestIterFieldNumber = 7;
  inline ::google::protobuf::int32 test_iter() const;
  inline void set_test_iter(::google::protobuf::int32 value);

  // optional string eval_type = 8 [default = "classification"];
  inline bool has_eval_type() const;
  inline void clear_eval_type();
  static const int kEvalTypeFieldNumber = 8;
  inline const ::std::string& eval_type() const;
  inline void set_eval_type(const ::std::string& value);
  inline void set_eval_type(const char* value);
  inline void set_eval_type(const char* value, size_t size);
  inline ::std::string* mutable_eval_type();
  inline ::std::string* release_eval_type();
  inline void set_allocated_eval_type(::std::string* eval_type);

  // optional bool accumulate_batch_norm = 9 [default = false];
  inline bool has_accumulate_batch_norm() const;
  inline void clear_accumulate_batch_norm();
  static const int kAccumulateBatchNormFieldNumber = 9;
  inline bool accumulate_batch_norm() const;
  inline void set_accumulate_batch_norm(bool value);

  // optional uint32 accumulate_test_iter = 10;
  inline bool has_accumulate_test_iter() const;
  inline void clear_accumulate_test_iter();
  static const int kAccumulateTestIterFieldNumber = 10;
  inline ::google::protobuf::uint32 accumulate_test_iter() const;
  inline void set_accumulate_test_iter(::google::protobuf::uint32 value);

  // optional uint32 accumulate_max_iter = 11;
  inline bool has_accumulate_max_iter() const;
  inline void clear_accumulate_max_iter();
  static const int kAccumulateMaxIterFieldNumber = 11;
  inline ::google::protobuf::uint32 accumulate_max_iter() const;
  inline void set_accumulate_max_iter(::google::protobuf::uint32 value);

  // optional int32 iter_size = 12 [default = 1];
  inline bool has_iter_size() const;
  inline void clear_iter_size();
  static const int kIterSizeFieldNumber = 12;
  inline ::google::protobuf::int32 iter_size() const;
  inline void set_iter_size(::google::protobuf::int32 value);

  // optional int32 snapshot = 13 [default = 0];
  inline bool has_snapshot() const;
  inline void clear_snapshot();
  static const int kSnapshotFieldNumber = 13;
  inline ::google::protobuf::int32 snapshot() const;
  inline void set_snapshot(::google::protobuf::int32 value);

  // optional string snapshot_prefix = 14;
  inline bool has_snapshot_prefix() const;
  inline void clear_snapshot_prefix();
  static const int kSnapshotPrefixFieldNumber = 14;
  inline const ::std::string& snapshot_prefix() const;
  inline void set_snapshot_prefix(const ::std::string& value);
  inline void set_snapshot_prefix(const char* value);
  inline void set_snapshot_prefix(const char* value, size_t size);
  inline ::std::string* mutable_snapshot_prefix();
  inline ::std::string* release_snapshot_prefix();
  inline void set_allocated_snapshot_prefix(::std::string* snapshot_prefix);

  // optional string solver_type = 15 [default = "CNN"];
  inline bool has_solver_type() const;
  inline void clear_solver_type();
  static const int kSolverTypeFieldNumber = 15;
  inline const ::std::string& solver_type() const;
  inline void set_solver_type(const ::std::string& value);
  inline void set_solver_type(const char* value);
  inline void set_solver_type(const char* value, size_t size);
  inline ::std::string* mutable_solver_type();
  inline ::std::string* release_solver_type();
  inline void set_allocated_solver_type(::std::string* solver_type);

  // optional int32 display = 16;
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 16;
  inline ::google::protobuf::int32 display() const;
  inline void set_display(::google::protobuf::int32 value);

  // optional string bn_state = 18 [default = "learned"];
  inline bool has_bn_state() const;
  inline void clear_bn_state();
  static const int kBnStateFieldNumber = 18;
  inline const ::std::string& bn_state() const;
  inline void set_bn_state(const ::std::string& value);
  inline void set_bn_state(const char* value);
  inline void set_bn_state(const char* value, size_t size);
  inline ::std::string* mutable_bn_state();
  inline ::std::string* release_bn_state();
  inline void set_allocated_bn_state(::std::string* bn_state);

  // optional string drop_state = 19 [default = "rand"];
  inline bool has_drop_state() const;
  inline void clear_drop_state();
  static const int kDropStateFieldNumber = 19;
  inline const ::std::string& drop_state() const;
  inline void set_drop_state(const ::std::string& value);
  inline void set_drop_state(const char* value);
  inline void set_drop_state(const char* value, size_t size);
  inline ::std::string* mutable_drop_state();
  inline ::std::string* release_drop_state();
  inline void set_allocated_drop_state(::std::string* drop_state);

  // optional bool second_pass = 20 [default = false];
  inline bool has_second_pass() const;
  inline void clear_second_pass();
  static const int kSecondPassFieldNumber = 20;
  inline bool second_pass() const;
  inline void set_second_pass(bool value);

  // optional string test_net = 21;
  inline bool has_test_net() const;
  inline void clear_test_net();
  static const int kTestNetFieldNumber = 21;
  inline const ::std::string& test_net() const;
  inline void set_test_net(const ::std::string& value);
  inline void set_test_net(const char* value);
  inline void set_test_net(const char* value, size_t size);
  inline ::std::string* mutable_test_net();
  inline ::std::string* release_test_net();
  inline void set_allocated_test_net(::std::string* test_net);

  // optional .caffe.NetOptimizer g_net_opt = 100;
  inline bool has_g_net_opt() const;
  inline void clear_g_net_opt();
  static const int kGNetOptFieldNumber = 100;
  inline const ::caffe::NetOptimizer& g_net_opt() const;
  inline ::caffe::NetOptimizer* mutable_g_net_opt();
  inline ::caffe::NetOptimizer* release_g_net_opt();
  inline void set_allocated_g_net_opt(::caffe::NetOptimizer* g_net_opt);

  // optional .caffe.NetOptimizer d_net_opt = 101;
  inline bool has_d_net_opt() const;
  inline void clear_d_net_opt();
  static const int kDNetOptFieldNumber = 101;
  inline const ::caffe::NetOptimizer& d_net_opt() const;
  inline ::caffe::NetOptimizer* mutable_d_net_opt();
  inline ::caffe::NetOptimizer* release_d_net_opt();
  inline void set_allocated_d_net_opt(::caffe::NetOptimizer* d_net_opt);

  // optional string g_net = 102;
  inline bool has_g_net() const;
  inline void clear_g_net();
  static const int kGNetFieldNumber = 102;
  inline const ::std::string& g_net() const;
  inline void set_g_net(const ::std::string& value);
  inline void set_g_net(const char* value);
  inline void set_g_net(const char* value, size_t size);
  inline ::std::string* mutable_g_net();
  inline ::std::string* release_g_net();
  inline void set_allocated_g_net(::std::string* g_net);

  // optional .caffe.NetParameter g_net_param = 103;
  inline bool has_g_net_param() const;
  inline void clear_g_net_param();
  static const int kGNetParamFieldNumber = 103;
  inline const ::caffe::NetParameter& g_net_param() const;
  inline ::caffe::NetParameter* mutable_g_net_param();
  inline ::caffe::NetParameter* release_g_net_param();
  inline void set_allocated_g_net_param(::caffe::NetParameter* g_net_param);

  // optional string d_net = 106;
  inline bool has_d_net() const;
  inline void clear_d_net();
  static const int kDNetFieldNumber = 106;
  inline const ::std::string& d_net() const;
  inline void set_d_net(const ::std::string& value);
  inline void set_d_net(const char* value);
  inline void set_d_net(const char* value, size_t size);
  inline ::std::string* mutable_d_net();
  inline ::std::string* release_d_net();
  inline void set_allocated_d_net(::std::string* d_net);

  // optional .caffe.NetParameter d_net_param = 107;
  inline bool has_d_net_param() const;
  inline void clear_d_net_param();
  static const int kDNetParamFieldNumber = 107;
  inline const ::caffe::NetParameter& d_net_param() const;
  inline ::caffe::NetParameter* mutable_d_net_param();
  inline ::caffe::NetParameter* release_d_net_param();
  inline void set_allocated_d_net_param(::caffe::NetParameter* d_net_param);

  // optional string d_interp_net = 110;
  inline bool has_d_interp_net() const;
  inline void clear_d_interp_net();
  static const int kDInterpNetFieldNumber = 110;
  inline const ::std::string& d_interp_net() const;
  inline void set_d_interp_net(const ::std::string& value);
  inline void set_d_interp_net(const char* value);
  inline void set_d_interp_net(const char* value, size_t size);
  inline ::std::string* mutable_d_interp_net();
  inline ::std::string* release_d_interp_net();
  inline void set_allocated_d_interp_net(::std::string* d_interp_net);

  // optional string d_aux_net = 111;
  inline bool has_d_aux_net() const;
  inline void clear_d_aux_net();
  static const int kDAuxNetFieldNumber = 111;
  inline const ::std::string& d_aux_net() const;
  inline void set_d_aux_net(const ::std::string& value);
  inline void set_d_aux_net(const char* value);
  inline void set_d_aux_net(const char* value, size_t size);
  inline ::std::string* mutable_d_aux_net();
  inline ::std::string* release_d_aux_net();
  inline void set_allocated_d_aux_net(::std::string* d_aux_net);

  // optional .caffe.NetParameter d_interp_param = 112;
  inline bool has_d_interp_param() const;
  inline void clear_d_interp_param();
  static const int kDInterpParamFieldNumber = 112;
  inline const ::caffe::NetParameter& d_interp_param() const;
  inline ::caffe::NetParameter* mutable_d_interp_param();
  inline ::caffe::NetParameter* release_d_interp_param();
  inline void set_allocated_d_interp_param(::caffe::NetParameter* d_interp_param);

  // optional .caffe.NetParameter d_aux_param = 113;
  inline bool has_d_aux_param() const;
  inline void clear_d_aux_param();
  static const int kDAuxParamFieldNumber = 113;
  inline const ::caffe::NetParameter& d_aux_param() const;
  inline ::caffe::NetParameter* mutable_d_aux_param();
  inline ::caffe::NetParameter* release_d_aux_param();
  inline void set_allocated_d_aux_param(::caffe::NetParameter* d_aux_param);

  // @@protoc_insertion_point(class_scope:caffe.SolverParameter)
 private:
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_net_param();
  inline void clear_has_net_param();
  inline void set_has_net_opt();
  inline void clear_has_net_opt();
  inline void set_has_max_iter();
  inline void clear_has_max_iter();
  inline void set_has_test_initialization();
  inline void clear_has_test_initialization();
  inline void set_has_test_interval();
  inline void clear_has_test_interval();
  inline void set_has_test_iter();
  inline void clear_has_test_iter();
  inline void set_has_eval_type();
  inline void clear_has_eval_type();
  inline void set_has_accumulate_batch_norm();
  inline void clear_has_accumulate_batch_norm();
  inline void set_has_accumulate_test_iter();
  inline void clear_has_accumulate_test_iter();
  inline void set_has_accumulate_max_iter();
  inline void clear_has_accumulate_max_iter();
  inline void set_has_iter_size();
  inline void clear_has_iter_size();
  inline void set_has_snapshot();
  inline void clear_has_snapshot();
  inline void set_has_snapshot_prefix();
  inline void clear_has_snapshot_prefix();
  inline void set_has_solver_type();
  inline void clear_has_solver_type();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_bn_state();
  inline void clear_has_bn_state();
  inline void set_has_drop_state();
  inline void clear_has_drop_state();
  inline void set_has_second_pass();
  inline void clear_has_second_pass();
  inline void set_has_test_net();
  inline void clear_has_test_net();
  inline void set_has_g_net_opt();
  inline void clear_has_g_net_opt();
  inline void set_has_d_net_opt();
  inline void clear_has_d_net_opt();
  inline void set_has_g_net();
  inline void clear_has_g_net();
  inline void set_has_g_net_param();
  inline void clear_has_g_net_param();
  inline void set_has_d_net();
  inline void clear_has_d_net();
  inline void set_has_d_net_param();
  inline void clear_has_d_net_param();
  inline void set_has_d_interp_net();
  inline void clear_has_d_interp_net();
  inline void set_has_d_aux_net();
  inline void clear_has_d_aux_net();
  inline void set_has_d_interp_param();
  inline void clear_has_d_interp_param();
  inline void set_has_d_aux_param();
  inline void clear_has_d_aux_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* net_;
  ::caffe::NetParameter* net_param_;
  ::caffe::NetOptimizer* net_opt_;
  ::google::protobuf::int32 max_iter_;
  ::google::protobuf::int32 test_interval_;
  ::std::string* eval_type_;
  static ::std::string* _default_eval_type_;
  ::google::protobuf::int32 test_iter_;
  ::google::protobuf::uint32 accumulate_test_iter_;
  ::google::protobuf::uint32 accumulate_max_iter_;
  bool test_initialization_;
  bool accumulate_batch_norm_;
  bool second_pass_;
  ::google::protobuf::int32 iter_size_;
  ::google::protobuf::int32 snapshot_;
  ::std::string* snapshot_prefix_;
  ::std::string* solver_type_;
  static ::std::string* _default_solver_type_;
  ::std::string* bn_state_;
  static ::std::string* _default_bn_state_;
  ::std::string* drop_state_;
  static ::std::string* _default_drop_state_;
  ::std::string* test_net_;
  ::caffe::NetOptimizer* g_net_opt_;
  ::caffe::NetOptimizer* d_net_opt_;
  ::std::string* g_net_;
  ::caffe::NetParameter* g_net_param_;
  ::std::string* d_net_;
  ::caffe::NetParameter* d_net_param_;
  ::std::string* d_interp_net_;
  ::std::string* d_aux_net_;
  ::caffe::NetParameter* d_interp_param_;
  ::caffe::NetParameter* d_aux_param_;
  ::google::protobuf::int32 display_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static SolverParameter* default_instance_;
};
// -------------------------------------------------------------------

class PoolingParameter : public ::google::protobuf::Message {
 public:
  PoolingParameter();
  virtual ~PoolingParameter();

  PoolingParameter(const PoolingParameter& from);

  inline PoolingParameter& operator=(const PoolingParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoolingParameter& default_instance();

  void Swap(PoolingParameter* other);

  // implements Message ----------------------------------------------

  PoolingParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoolingParameter& from);
  void MergeFrom(const PoolingParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pool = 1 [default = "ave"];
  inline bool has_pool() const;
  inline void clear_pool();
  static const int kPoolFieldNumber = 1;
  inline const ::std::string& pool() const;
  inline void set_pool(const ::std::string& value);
  inline void set_pool(const char* value);
  inline void set_pool(const char* value, size_t size);
  inline ::std::string* mutable_pool();
  inline ::std::string* release_pool();
  inline void set_allocated_pool(::std::string* pool);

  // optional uint32 pad = 2 [default = 0];
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 2;
  inline ::google::protobuf::uint32 pad() const;
  inline void set_pad(::google::protobuf::uint32 value);

  // optional uint32 kernel_size = 3;
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 kernel_size() const;
  inline void set_kernel_size(::google::protobuf::uint32 value);

  // optional uint32 stride = 4 [default = 1];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 4;
  inline ::google::protobuf::uint32 stride() const;
  inline void set_stride(::google::protobuf::uint32 value);

  // optional bool global_pool = 5 [default = false];
  inline bool has_global_pool() const;
  inline void clear_global_pool();
  static const int kGlobalPoolFieldNumber = 5;
  inline bool global_pool() const;
  inline void set_global_pool(bool value);

  // @@protoc_insertion_point(class_scope:caffe.PoolingParameter)
 private:
  inline void set_has_pool();
  inline void clear_has_pool();
  inline void set_has_pad();
  inline void clear_has_pad();
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_global_pool();
  inline void clear_has_global_pool();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pool_;
  static ::std::string* _default_pool_;
  ::google::protobuf::uint32 pad_;
  ::google::protobuf::uint32 kernel_size_;
  ::google::protobuf::uint32 stride_;
  bool global_pool_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static PoolingParameter* default_instance_;
};
// -------------------------------------------------------------------

class LossParameter : public ::google::protobuf::Message {
 public:
  LossParameter();
  virtual ~LossParameter();

  LossParameter(const LossParameter& from);

  inline LossParameter& operator=(const LossParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LossParameter& default_instance();

  void Swap(LossParameter* other);

  // implements Message ----------------------------------------------

  LossParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LossParameter& from);
  void MergeFrom(const LossParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ignore_label = 1;
  inline bool has_ignore_label() const;
  inline void clear_ignore_label();
  static const int kIgnoreLabelFieldNumber = 1;
  inline ::google::protobuf::int32 ignore_label() const;
  inline void set_ignore_label(::google::protobuf::int32 value);

  // optional float keep_portion = 2 [default = 0.5];
  inline bool has_keep_portion() const;
  inline void clear_keep_portion();
  static const int kKeepPortionFieldNumber = 2;
  inline float keep_portion() const;
  inline void set_keep_portion(float value);

  // optional bool single_term = 3 [default = false];
  inline bool has_single_term() const;
  inline void clear_single_term();
  static const int kSingleTermFieldNumber = 3;
  inline bool single_term() const;
  inline void set_single_term(bool value);

  // @@protoc_insertion_point(class_scope:caffe.LossParameter)
 private:
  inline void set_has_ignore_label();
  inline void clear_has_ignore_label();
  inline void set_has_keep_portion();
  inline void clear_has_keep_portion();
  inline void set_has_single_term();
  inline void clear_has_single_term();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ignore_label_;
  float keep_portion_;
  bool single_term_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_AssignDesc_src_2fcaffe_2fproto_2fcaffe_2eproto();
  friend void protobuf_ShutdownFile_src_2fcaffe_2fproto_2fcaffe_2eproto();

  void InitAsDefaultInstance();
  static LossParameter* default_instance_;
};
// ===================================================================


// ===================================================================

// BlobShape

// repeated int64 dim = 5 [packed = true];
inline int BlobShape::dim_size() const {
  return dim_.size();
}
inline void BlobShape::clear_dim() {
  dim_.Clear();
}
inline ::google::protobuf::int64 BlobShape::dim(int index) const {
  return dim_.Get(index);
}
inline void BlobShape::set_dim(int index, ::google::protobuf::int64 value) {
  dim_.Set(index, value);
}
inline void BlobShape::add_dim(::google::protobuf::int64 value) {
  dim_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
BlobShape::dim() const {
  return dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
BlobShape::mutable_dim() {
  return &dim_;
}

// optional int32 num = 1;
inline bool BlobShape::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobShape::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobShape::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobShape::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BlobShape::num() const {
  return num_;
}
inline void BlobShape::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 channels = 2;
inline bool BlobShape::has_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlobShape::set_has_channels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlobShape::clear_has_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlobShape::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 BlobShape::channels() const {
  return channels_;
}
inline void BlobShape::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 3;
inline bool BlobShape::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlobShape::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlobShape::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlobShape::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 BlobShape::height() const {
  return height_;
}
inline void BlobShape::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 4;
inline bool BlobShape::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlobShape::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlobShape::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlobShape::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 BlobShape::width() const {
  return width_;
}
inline void BlobShape::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional bool forced = 6 [default = false];
inline bool BlobShape::has_forced() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlobShape::set_has_forced() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlobShape::clear_has_forced() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlobShape::clear_forced() {
  forced_ = false;
  clear_has_forced();
}
inline bool BlobShape::forced() const {
  return forced_;
}
inline void BlobShape::set_forced(bool value) {
  set_has_forced();
  forced_ = value;
}

// -------------------------------------------------------------------

// BlobProto

// repeated float data = 5 [packed = true];
inline int BlobProto::data_size() const {
  return data_.size();
}
inline void BlobProto::clear_data() {
  data_.Clear();
}
inline float BlobProto::data(int index) const {
  return data_.Get(index);
}
inline void BlobProto::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void BlobProto::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
BlobProto::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
BlobProto::mutable_data() {
  return &data_;
}

// repeated float diff = 6 [packed = true];
inline int BlobProto::diff_size() const {
  return diff_.size();
}
inline void BlobProto::clear_diff() {
  diff_.Clear();
}
inline float BlobProto::diff(int index) const {
  return diff_.Get(index);
}
inline void BlobProto::set_diff(int index, float value) {
  diff_.Set(index, value);
}
inline void BlobProto::add_diff(float value) {
  diff_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
BlobProto::diff() const {
  return diff_;
}
inline ::google::protobuf::RepeatedField< float >*
BlobProto::mutable_diff() {
  return &diff_;
}

// optional .caffe.BlobShape shape = 7;
inline bool BlobProto::has_shape() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlobProto::set_has_shape() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlobProto::clear_has_shape() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlobProto::clear_shape() {
  if (shape_ != NULL) shape_->::caffe::BlobShape::Clear();
  clear_has_shape();
}
inline const ::caffe::BlobShape& BlobProto::shape() const {
  return shape_ != NULL ? *shape_ : *default_instance_->shape_;
}
inline ::caffe::BlobShape* BlobProto::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) shape_ = new ::caffe::BlobShape;
  return shape_;
}
inline ::caffe::BlobShape* BlobProto::release_shape() {
  clear_has_shape();
  ::caffe::BlobShape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline void BlobProto::set_allocated_shape(::caffe::BlobShape* shape) {
  delete shape_;
  shape_ = shape;
  if (shape) {
    set_has_shape();
  } else {
    clear_has_shape();
  }
}

// optional int32 num = 1 [default = 0];
inline bool BlobProto::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlobProto::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlobProto::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlobProto::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BlobProto::num() const {
  return num_;
}
inline void BlobProto::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 channels = 2 [default = 0];
inline bool BlobProto::has_channels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlobProto::set_has_channels() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlobProto::clear_has_channels() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlobProto::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 BlobProto::channels() const {
  return channels_;
}
inline void BlobProto::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 3 [default = 0];
inline bool BlobProto::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlobProto::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlobProto::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlobProto::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 BlobProto::height() const {
  return height_;
}
inline void BlobProto::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 4 [default = 0];
inline bool BlobProto::has_width() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlobProto::set_has_width() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlobProto::clear_has_width() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlobProto::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 BlobProto::width() const {
  return width_;
}
inline void BlobProto::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// -------------------------------------------------------------------

// Datum

// optional int32 channels = 1;
inline bool Datum::has_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datum::set_has_channels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datum::clear_has_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datum::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 Datum::channels() const {
  return channels_;
}
inline void Datum::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 2;
inline bool Datum::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datum::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datum::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datum::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Datum::height() const {
  return height_;
}
inline void Datum::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 3;
inline bool Datum::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Datum::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Datum::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Datum::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Datum::width() const {
  return width_;
}
inline void Datum::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional bytes data = 4;
inline bool Datum::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Datum::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Datum::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Datum::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Datum::data() const {
  return *data_;
}
inline void Datum::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Datum::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Datum::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datum::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Datum::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Datum::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 label = 5;
inline bool Datum::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Datum::set_has_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Datum::clear_has_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Datum::clear_label() {
  label_ = 0;
  clear_has_label();
}
inline ::google::protobuf::int32 Datum::label() const {
  return label_;
}
inline void Datum::set_label(::google::protobuf::int32 value) {
  set_has_label();
  label_ = value;
}

// repeated float float_data = 6;
inline int Datum::float_data_size() const {
  return float_data_.size();
}
inline void Datum::clear_float_data() {
  float_data_.Clear();
}
inline float Datum::float_data(int index) const {
  return float_data_.Get(index);
}
inline void Datum::set_float_data(int index, float value) {
  float_data_.Set(index, value);
}
inline void Datum::add_float_data(float value) {
  float_data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Datum::float_data() const {
  return float_data_;
}
inline ::google::protobuf::RepeatedField< float >*
Datum::mutable_float_data() {
  return &float_data_;
}

// optional bool encoded = 7 [default = false];
inline bool Datum::has_encoded() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Datum::set_has_encoded() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Datum::clear_has_encoded() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Datum::clear_encoded() {
  encoded_ = false;
  clear_has_encoded();
}
inline bool Datum::encoded() const {
  return encoded_;
}
inline void Datum::set_encoded(bool value) {
  set_has_encoded();
  encoded_ = value;
}

// repeated int32 multi_label = 8;
inline int Datum::multi_label_size() const {
  return multi_label_.size();
}
inline void Datum::clear_multi_label() {
  multi_label_.Clear();
}
inline ::google::protobuf::int32 Datum::multi_label(int index) const {
  return multi_label_.Get(index);
}
inline void Datum::set_multi_label(int index, ::google::protobuf::int32 value) {
  multi_label_.Set(index, value);
}
inline void Datum::add_multi_label(::google::protobuf::int32 value) {
  multi_label_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Datum::multi_label() const {
  return multi_label_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Datum::mutable_multi_label() {
  return &multi_label_;
}

// -------------------------------------------------------------------

// FillerParameter

// optional string type = 1 [default = "msra"];
inline bool FillerParameter::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FillerParameter::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FillerParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FillerParameter::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& FillerParameter::type() const {
  return *type_;
}
inline void FillerParameter::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FillerParameter::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FillerParameter::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FillerParameter::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  return type_;
}
inline ::std::string* FillerParameter::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void FillerParameter::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
}

// optional string variance_norm = 2 [default = "fan_in"];
inline bool FillerParameter::has_variance_norm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FillerParameter::set_has_variance_norm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FillerParameter::clear_has_variance_norm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FillerParameter::clear_variance_norm() {
  if (variance_norm_ != _default_variance_norm_) {
    variance_norm_->assign(*_default_variance_norm_);
  }
  clear_has_variance_norm();
}
inline const ::std::string& FillerParameter::variance_norm() const {
  return *variance_norm_;
}
inline void FillerParameter::set_variance_norm(const ::std::string& value) {
  set_has_variance_norm();
  if (variance_norm_ == _default_variance_norm_) {
    variance_norm_ = new ::std::string;
  }
  variance_norm_->assign(value);
}
inline void FillerParameter::set_variance_norm(const char* value) {
  set_has_variance_norm();
  if (variance_norm_ == _default_variance_norm_) {
    variance_norm_ = new ::std::string;
  }
  variance_norm_->assign(value);
}
inline void FillerParameter::set_variance_norm(const char* value, size_t size) {
  set_has_variance_norm();
  if (variance_norm_ == _default_variance_norm_) {
    variance_norm_ = new ::std::string;
  }
  variance_norm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FillerParameter::mutable_variance_norm() {
  set_has_variance_norm();
  if (variance_norm_ == _default_variance_norm_) {
    variance_norm_ = new ::std::string(*_default_variance_norm_);
  }
  return variance_norm_;
}
inline ::std::string* FillerParameter::release_variance_norm() {
  clear_has_variance_norm();
  if (variance_norm_ == _default_variance_norm_) {
    return NULL;
  } else {
    ::std::string* temp = variance_norm_;
    variance_norm_ = const_cast< ::std::string*>(_default_variance_norm_);
    return temp;
  }
}
inline void FillerParameter::set_allocated_variance_norm(::std::string* variance_norm) {
  if (variance_norm_ != _default_variance_norm_) {
    delete variance_norm_;
  }
  if (variance_norm) {
    set_has_variance_norm();
    variance_norm_ = variance_norm;
  } else {
    clear_has_variance_norm();
    variance_norm_ = const_cast< ::std::string*>(_default_variance_norm_);
  }
}

// optional float mean = 3;
inline bool FillerParameter::has_mean() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FillerParameter::set_has_mean() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FillerParameter::clear_has_mean() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FillerParameter::clear_mean() {
  mean_ = 0;
  clear_has_mean();
}
inline float FillerParameter::mean() const {
  return mean_;
}
inline void FillerParameter::set_mean(float value) {
  set_has_mean();
  mean_ = value;
}

// optional float std = 4;
inline bool FillerParameter::has_std() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FillerParameter::set_has_std() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FillerParameter::clear_has_std() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FillerParameter::clear_std() {
  std_ = 0;
  clear_has_std();
}
inline float FillerParameter::std() const {
  return std_;
}
inline void FillerParameter::set_std(float value) {
  set_has_std();
  std_ = value;
}

// -------------------------------------------------------------------

// InnerProductParameter

// optional uint32 num_output = 1;
inline bool InnerProductParameter::has_num_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerProductParameter::set_has_num_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerProductParameter::clear_has_num_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerProductParameter::clear_num_output() {
  num_output_ = 0u;
  clear_has_num_output();
}
inline ::google::protobuf::uint32 InnerProductParameter::num_output() const {
  return num_output_;
}
inline void InnerProductParameter::set_num_output(::google::protobuf::uint32 value) {
  set_has_num_output();
  num_output_ = value;
}

// optional bool bias_term = 2 [default = false];
inline bool InnerProductParameter::has_bias_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerProductParameter::set_has_bias_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerProductParameter::clear_has_bias_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerProductParameter::clear_bias_term() {
  bias_term_ = false;
  clear_has_bias_term();
}
inline bool InnerProductParameter::bias_term() const {
  return bias_term_;
}
inline void InnerProductParameter::set_bias_term(bool value) {
  set_has_bias_term();
  bias_term_ = value;
}

// optional .caffe.FillerParameter weight_filler = 3;
inline bool InnerProductParameter::has_weight_filler() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InnerProductParameter::set_has_weight_filler() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InnerProductParameter::clear_has_weight_filler() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InnerProductParameter::clear_weight_filler() {
  if (weight_filler_ != NULL) weight_filler_->::caffe::FillerParameter::Clear();
  clear_has_weight_filler();
}
inline const ::caffe::FillerParameter& InnerProductParameter::weight_filler() const {
  return weight_filler_ != NULL ? *weight_filler_ : *default_instance_->weight_filler_;
}
inline ::caffe::FillerParameter* InnerProductParameter::mutable_weight_filler() {
  set_has_weight_filler();
  if (weight_filler_ == NULL) weight_filler_ = new ::caffe::FillerParameter;
  return weight_filler_;
}
inline ::caffe::FillerParameter* InnerProductParameter::release_weight_filler() {
  clear_has_weight_filler();
  ::caffe::FillerParameter* temp = weight_filler_;
  weight_filler_ = NULL;
  return temp;
}
inline void InnerProductParameter::set_allocated_weight_filler(::caffe::FillerParameter* weight_filler) {
  delete weight_filler_;
  weight_filler_ = weight_filler;
  if (weight_filler) {
    set_has_weight_filler();
  } else {
    clear_has_weight_filler();
  }
}

// -------------------------------------------------------------------

// ConvolutionParameter

// optional uint32 num_output = 1;
inline bool ConvolutionParameter::has_num_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvolutionParameter::set_has_num_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvolutionParameter::clear_has_num_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvolutionParameter::clear_num_output() {
  num_output_ = 0u;
  clear_has_num_output();
}
inline ::google::protobuf::uint32 ConvolutionParameter::num_output() const {
  return num_output_;
}
inline void ConvolutionParameter::set_num_output(::google::protobuf::uint32 value) {
  set_has_num_output();
  num_output_ = value;
}

// optional bool bias_term = 2 [default = false];
inline bool ConvolutionParameter::has_bias_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvolutionParameter::set_has_bias_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvolutionParameter::clear_has_bias_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvolutionParameter::clear_bias_term() {
  bias_term_ = false;
  clear_has_bias_term();
}
inline bool ConvolutionParameter::bias_term() const {
  return bias_term_;
}
inline void ConvolutionParameter::set_bias_term(bool value) {
  set_has_bias_term();
  bias_term_ = value;
}

// optional uint32 pad = 3 [default = 0];
inline bool ConvolutionParameter::has_pad() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConvolutionParameter::set_has_pad() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConvolutionParameter::clear_has_pad() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConvolutionParameter::clear_pad() {
  pad_ = 0u;
  clear_has_pad();
}
inline ::google::protobuf::uint32 ConvolutionParameter::pad() const {
  return pad_;
}
inline void ConvolutionParameter::set_pad(::google::protobuf::uint32 value) {
  set_has_pad();
  pad_ = value;
}

// optional uint32 kernel_size = 4;
inline bool ConvolutionParameter::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConvolutionParameter::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConvolutionParameter::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConvolutionParameter::clear_kernel_size() {
  kernel_size_ = 0u;
  clear_has_kernel_size();
}
inline ::google::protobuf::uint32 ConvolutionParameter::kernel_size() const {
  return kernel_size_;
}
inline void ConvolutionParameter::set_kernel_size(::google::protobuf::uint32 value) {
  set_has_kernel_size();
  kernel_size_ = value;
}

// optional uint32 stride = 5 [default = 1];
inline bool ConvolutionParameter::has_stride() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConvolutionParameter::set_has_stride() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConvolutionParameter::clear_has_stride() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConvolutionParameter::clear_stride() {
  stride_ = 1u;
  clear_has_stride();
}
inline ::google::protobuf::uint32 ConvolutionParameter::stride() const {
  return stride_;
}
inline void ConvolutionParameter::set_stride(::google::protobuf::uint32 value) {
  set_has_stride();
  stride_ = value;
}

// optional uint32 filter_stride = 6 [default = 1];
inline bool ConvolutionParameter::has_filter_stride() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConvolutionParameter::set_has_filter_stride() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConvolutionParameter::clear_has_filter_stride() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConvolutionParameter::clear_filter_stride() {
  filter_stride_ = 1u;
  clear_has_filter_stride();
}
inline ::google::protobuf::uint32 ConvolutionParameter::filter_stride() const {
  return filter_stride_;
}
inline void ConvolutionParameter::set_filter_stride(::google::protobuf::uint32 value) {
  set_has_filter_stride();
  filter_stride_ = value;
}

// optional .caffe.FillerParameter weight_filler = 7;
inline bool ConvolutionParameter::has_weight_filler() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConvolutionParameter::set_has_weight_filler() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConvolutionParameter::clear_has_weight_filler() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConvolutionParameter::clear_weight_filler() {
  if (weight_filler_ != NULL) weight_filler_->::caffe::FillerParameter::Clear();
  clear_has_weight_filler();
}
inline const ::caffe::FillerParameter& ConvolutionParameter::weight_filler() const {
  return weight_filler_ != NULL ? *weight_filler_ : *default_instance_->weight_filler_;
}
inline ::caffe::FillerParameter* ConvolutionParameter::mutable_weight_filler() {
  set_has_weight_filler();
  if (weight_filler_ == NULL) weight_filler_ = new ::caffe::FillerParameter;
  return weight_filler_;
}
inline ::caffe::FillerParameter* ConvolutionParameter::release_weight_filler() {
  clear_has_weight_filler();
  ::caffe::FillerParameter* temp = weight_filler_;
  weight_filler_ = NULL;
  return temp;
}
inline void ConvolutionParameter::set_allocated_weight_filler(::caffe::FillerParameter* weight_filler) {
  delete weight_filler_;
  weight_filler_ = weight_filler;
  if (weight_filler) {
    set_has_weight_filler();
  } else {
    clear_has_weight_filler();
  }
}

// optional uint32 group = 8 [default = 1];
inline bool ConvolutionParameter::has_group() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ConvolutionParameter::set_has_group() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ConvolutionParameter::clear_has_group() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ConvolutionParameter::clear_group() {
  group_ = 1u;
  clear_has_group();
}
inline ::google::protobuf::uint32 ConvolutionParameter::group() const {
  return group_;
}
inline void ConvolutionParameter::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
}

// optional string weight_file = 9;
inline bool ConvolutionParameter::has_weight_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ConvolutionParameter::set_has_weight_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ConvolutionParameter::clear_has_weight_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ConvolutionParameter::clear_weight_file() {
  if (weight_file_ != &::google::protobuf::internal::kEmptyString) {
    weight_file_->clear();
  }
  clear_has_weight_file();
}
inline const ::std::string& ConvolutionParameter::weight_file() const {
  return *weight_file_;
}
inline void ConvolutionParameter::set_weight_file(const ::std::string& value) {
  set_has_weight_file();
  if (weight_file_ == &::google::protobuf::internal::kEmptyString) {
    weight_file_ = new ::std::string;
  }
  weight_file_->assign(value);
}
inline void ConvolutionParameter::set_weight_file(const char* value) {
  set_has_weight_file();
  if (weight_file_ == &::google::protobuf::internal::kEmptyString) {
    weight_file_ = new ::std::string;
  }
  weight_file_->assign(value);
}
inline void ConvolutionParameter::set_weight_file(const char* value, size_t size) {
  set_has_weight_file();
  if (weight_file_ == &::google::protobuf::internal::kEmptyString) {
    weight_file_ = new ::std::string;
  }
  weight_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConvolutionParameter::mutable_weight_file() {
  set_has_weight_file();
  if (weight_file_ == &::google::protobuf::internal::kEmptyString) {
    weight_file_ = new ::std::string;
  }
  return weight_file_;
}
inline ::std::string* ConvolutionParameter::release_weight_file() {
  clear_has_weight_file();
  if (weight_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weight_file_;
    weight_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConvolutionParameter::set_allocated_weight_file(::std::string* weight_file) {
  if (weight_file_ != &::google::protobuf::internal::kEmptyString) {
    delete weight_file_;
  }
  if (weight_file) {
    set_has_weight_file();
    weight_file_ = weight_file;
  } else {
    clear_has_weight_file();
    weight_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 multi = 10;
inline bool ConvolutionParameter::has_multi() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ConvolutionParameter::set_has_multi() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ConvolutionParameter::clear_has_multi() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ConvolutionParameter::clear_multi() {
  multi_ = 0u;
  clear_has_multi();
}
inline ::google::protobuf::uint32 ConvolutionParameter::multi() const {
  return multi_;
}
inline void ConvolutionParameter::set_multi(::google::protobuf::uint32 value) {
  set_has_multi();
  multi_ = value;
}

// optional bool random_field = 11 [default = false];
inline bool ConvolutionParameter::has_random_field() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ConvolutionParameter::set_has_random_field() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ConvolutionParameter::clear_has_random_field() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ConvolutionParameter::clear_random_field() {
  random_field_ = false;
  clear_has_random_field();
}
inline bool ConvolutionParameter::random_field() const {
  return random_field_;
}
inline void ConvolutionParameter::set_random_field(bool value) {
  set_has_random_field();
  random_field_ = value;
}

// -------------------------------------------------------------------

// DataParameter

// repeated string source = 1;
inline int DataParameter::source_size() const {
  return source_.size();
}
inline void DataParameter::clear_source() {
  source_.Clear();
}
inline const ::std::string& DataParameter::source(int index) const {
  return source_.Get(index);
}
inline ::std::string* DataParameter::mutable_source(int index) {
  return source_.Mutable(index);
}
inline void DataParameter::set_source(int index, const ::std::string& value) {
  source_.Mutable(index)->assign(value);
}
inline void DataParameter::set_source(int index, const char* value) {
  source_.Mutable(index)->assign(value);
}
inline void DataParameter::set_source(int index, const char* value, size_t size) {
  source_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter::add_source() {
  return source_.Add();
}
inline void DataParameter::add_source(const ::std::string& value) {
  source_.Add()->assign(value);
}
inline void DataParameter::add_source(const char* value) {
  source_.Add()->assign(value);
}
inline void DataParameter::add_source(const char* value, size_t size) {
  source_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataParameter::source() const {
  return source_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataParameter::mutable_source() {
  return &source_;
}

// optional string root_folder = 2 [default = ""];
inline bool DataParameter::has_root_folder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataParameter::set_has_root_folder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataParameter::clear_has_root_folder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataParameter::clear_root_folder() {
  if (root_folder_ != &::google::protobuf::internal::kEmptyString) {
    root_folder_->clear();
  }
  clear_has_root_folder();
}
inline const ::std::string& DataParameter::root_folder() const {
  return *root_folder_;
}
inline void DataParameter::set_root_folder(const ::std::string& value) {
  set_has_root_folder();
  if (root_folder_ == &::google::protobuf::internal::kEmptyString) {
    root_folder_ = new ::std::string;
  }
  root_folder_->assign(value);
}
inline void DataParameter::set_root_folder(const char* value) {
  set_has_root_folder();
  if (root_folder_ == &::google::protobuf::internal::kEmptyString) {
    root_folder_ = new ::std::string;
  }
  root_folder_->assign(value);
}
inline void DataParameter::set_root_folder(const char* value, size_t size) {
  set_has_root_folder();
  if (root_folder_ == &::google::protobuf::internal::kEmptyString) {
    root_folder_ = new ::std::string;
  }
  root_folder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataParameter::mutable_root_folder() {
  set_has_root_folder();
  if (root_folder_ == &::google::protobuf::internal::kEmptyString) {
    root_folder_ = new ::std::string;
  }
  return root_folder_;
}
inline ::std::string* DataParameter::release_root_folder() {
  clear_has_root_folder();
  if (root_folder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = root_folder_;
    root_folder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataParameter::set_allocated_root_folder(::std::string* root_folder) {
  if (root_folder_ != &::google::protobuf::internal::kEmptyString) {
    delete root_folder_;
  }
  if (root_folder) {
    set_has_root_folder();
    root_folder_ = root_folder;
  } else {
    clear_has_root_folder();
    root_folder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 batch_size = 3 [default = 1];
inline bool DataParameter::has_batch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataParameter::set_has_batch_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataParameter::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataParameter::clear_batch_size() {
  batch_size_ = 1u;
  clear_has_batch_size();
}
inline ::google::protobuf::uint32 DataParameter::batch_size() const {
  return batch_size_;
}
inline void DataParameter::set_batch_size(::google::protobuf::uint32 value) {
  set_has_batch_size();
  batch_size_ = value;
}

// optional bool shuffle = 5 [default = false];
inline bool DataParameter::has_shuffle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataParameter::set_has_shuffle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataParameter::clear_has_shuffle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataParameter::clear_shuffle() {
  shuffle_ = false;
  clear_has_shuffle();
}
inline bool DataParameter::shuffle() const {
  return shuffle_;
}
inline void DataParameter::set_shuffle(bool value) {
  set_has_shuffle();
  shuffle_ = value;
}

// optional bool random_skip = 6 [default = false];
inline bool DataParameter::has_random_skip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataParameter::set_has_random_skip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataParameter::clear_has_random_skip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataParameter::clear_random_skip() {
  random_skip_ = false;
  clear_has_random_skip();
}
inline bool DataParameter::random_skip() const {
  return random_skip_;
}
inline void DataParameter::set_random_skip(bool value) {
  set_has_random_skip();
  random_skip_ = value;
}

// -------------------------------------------------------------------

// TransformationParameter

// optional bool mirror = 1 [default = true];
inline bool TransformationParameter::has_mirror() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformationParameter::set_has_mirror() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransformationParameter::clear_has_mirror() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransformationParameter::clear_mirror() {
  mirror_ = true;
  clear_has_mirror();
}
inline bool TransformationParameter::mirror() const {
  return mirror_;
}
inline void TransformationParameter::set_mirror(bool value) {
  set_has_mirror();
  mirror_ = value;
}

// optional int32 crop_size = 2 [default = 0];
inline bool TransformationParameter::has_crop_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransformationParameter::set_has_crop_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransformationParameter::clear_has_crop_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransformationParameter::clear_crop_size() {
  crop_size_ = 0;
  clear_has_crop_size();
}
inline ::google::protobuf::int32 TransformationParameter::crop_size() const {
  return crop_size_;
}
inline void TransformationParameter::set_crop_size(::google::protobuf::int32 value) {
  set_has_crop_size();
  crop_size_ = value;
}

// optional int32 augment_size = 3 [default = 0];
inline bool TransformationParameter::has_augment_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransformationParameter::set_has_augment_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransformationParameter::clear_has_augment_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransformationParameter::clear_augment_size() {
  augment_size_ = 0;
  clear_has_augment_size();
}
inline ::google::protobuf::int32 TransformationParameter::augment_size() const {
  return augment_size_;
}
inline void TransformationParameter::set_augment_size(::google::protobuf::int32 value) {
  set_has_augment_size();
  augment_size_ = value;
}

// repeated float mean_value = 4;
inline int TransformationParameter::mean_value_size() const {
  return mean_value_.size();
}
inline void TransformationParameter::clear_mean_value() {
  mean_value_.Clear();
}
inline float TransformationParameter::mean_value(int index) const {
  return mean_value_.Get(index);
}
inline void TransformationParameter::set_mean_value(int index, float value) {
  mean_value_.Set(index, value);
}
inline void TransformationParameter::add_mean_value(float value) {
  mean_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
TransformationParameter::mean_value() const {
  return mean_value_;
}
inline ::google::protobuf::RepeatedField< float >*
TransformationParameter::mutable_mean_value() {
  return &mean_value_;
}

// optional bool alter_color = 5 [default = true];
inline bool TransformationParameter::has_alter_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransformationParameter::set_has_alter_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransformationParameter::clear_has_alter_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransformationParameter::clear_alter_color() {
  alter_color_ = true;
  clear_has_alter_color();
}
inline bool TransformationParameter::alter_color() const {
  return alter_color_;
}
inline void TransformationParameter::set_alter_color(bool value) {
  set_has_alter_color();
  alter_color_ = value;
}

// optional bool pad_img = 6 [default = false];
inline bool TransformationParameter::has_pad_img() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransformationParameter::set_has_pad_img() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransformationParameter::clear_has_pad_img() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransformationParameter::clear_pad_img() {
  pad_img_ = false;
  clear_has_pad_img();
}
inline bool TransformationParameter::pad_img() const {
  return pad_img_;
}
inline void TransformationParameter::set_pad_img(bool value) {
  set_has_pad_img();
  pad_img_ = value;
}

// optional bool simple = 7 [default = false];
inline bool TransformationParameter::has_simple() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransformationParameter::set_has_simple() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransformationParameter::clear_has_simple() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransformationParameter::clear_simple() {
  simple_ = false;
  clear_has_simple();
}
inline bool TransformationParameter::simple() const {
  return simple_;
}
inline void TransformationParameter::set_simple(bool value) {
  set_has_simple();
  simple_ = value;
}

// optional bool center_crop = 8 [default = false];
inline bool TransformationParameter::has_center_crop() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransformationParameter::set_has_center_crop() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransformationParameter::clear_has_center_crop() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransformationParameter::clear_center_crop() {
  center_crop_ = false;
  clear_has_center_crop();
}
inline bool TransformationParameter::center_crop() const {
  return center_crop_;
}
inline void TransformationParameter::set_center_crop(bool value) {
  set_has_center_crop();
  center_crop_ = value;
}

// optional int32 ignore_label = 9 [default = 255];
inline bool TransformationParameter::has_ignore_label() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TransformationParameter::set_has_ignore_label() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TransformationParameter::clear_has_ignore_label() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TransformationParameter::clear_ignore_label() {
  ignore_label_ = 255;
  clear_has_ignore_label();
}
inline ::google::protobuf::int32 TransformationParameter::ignore_label() const {
  return ignore_label_;
}
inline void TransformationParameter::set_ignore_label(::google::protobuf::int32 value) {
  set_has_ignore_label();
  ignore_label_ = value;
}

// optional bool random_scale = 10 [default = true];
inline bool TransformationParameter::has_random_scale() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TransformationParameter::set_has_random_scale() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TransformationParameter::clear_has_random_scale() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TransformationParameter::clear_random_scale() {
  random_scale_ = true;
  clear_has_random_scale();
}
inline bool TransformationParameter::random_scale() const {
  return random_scale_;
}
inline void TransformationParameter::set_random_scale(bool value) {
  set_has_random_scale();
  random_scale_ = value;
}

// optional bool random_aspect = 11 [default = false];
inline bool TransformationParameter::has_random_aspect() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TransformationParameter::set_has_random_aspect() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TransformationParameter::clear_has_random_aspect() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TransformationParameter::clear_random_aspect() {
  random_aspect_ = false;
  clear_has_random_aspect();
}
inline bool TransformationParameter::random_aspect() const {
  return random_aspect_;
}
inline void TransformationParameter::set_random_aspect(bool value) {
  set_has_random_aspect();
  random_aspect_ = value;
}

// optional int32 resolution = 12 [default = 1];
inline bool TransformationParameter::has_resolution() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TransformationParameter::set_has_resolution() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TransformationParameter::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TransformationParameter::clear_resolution() {
  resolution_ = 1;
  clear_has_resolution();
}
inline ::google::protobuf::int32 TransformationParameter::resolution() const {
  return resolution_;
}
inline void TransformationParameter::set_resolution(::google::protobuf::int32 value) {
  set_has_resolution();
  resolution_ = value;
}

// optional int32 classes = 13 [default = 21];
inline bool TransformationParameter::has_classes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TransformationParameter::set_has_classes() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TransformationParameter::clear_has_classes() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TransformationParameter::clear_classes() {
  classes_ = 21;
  clear_has_classes();
}
inline ::google::protobuf::int32 TransformationParameter::classes() const {
  return classes_;
}
inline void TransformationParameter::set_classes(::google::protobuf::int32 value) {
  set_has_classes();
  classes_ = value;
}

// optional bool random_rotate = 14 [default = false];
inline bool TransformationParameter::has_random_rotate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TransformationParameter::set_has_random_rotate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TransformationParameter::clear_has_random_rotate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TransformationParameter::clear_random_rotate() {
  random_rotate_ = false;
  clear_has_random_rotate();
}
inline bool TransformationParameter::random_rotate() const {
  return random_rotate_;
}
inline void TransformationParameter::set_random_rotate(bool value) {
  set_has_random_rotate();
  random_rotate_ = value;
}

// -------------------------------------------------------------------

// ParamSpec

// optional float lr_mult = 1;
inline bool ParamSpec::has_lr_mult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParamSpec::set_has_lr_mult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParamSpec::clear_has_lr_mult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParamSpec::clear_lr_mult() {
  lr_mult_ = 0;
  clear_has_lr_mult();
}
inline float ParamSpec::lr_mult() const {
  return lr_mult_;
}
inline void ParamSpec::set_lr_mult(float value) {
  set_has_lr_mult();
  lr_mult_ = value;
}

// optional float decay_mult = 2;
inline bool ParamSpec::has_decay_mult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParamSpec::set_has_decay_mult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParamSpec::clear_has_decay_mult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParamSpec::clear_decay_mult() {
  decay_mult_ = 0;
  clear_has_decay_mult();
}
inline float ParamSpec::decay_mult() const {
  return decay_mult_;
}
inline void ParamSpec::set_decay_mult(float value) {
  set_has_decay_mult();
  decay_mult_ = value;
}

// optional float weight_norm = 3;
inline bool ParamSpec::has_weight_norm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParamSpec::set_has_weight_norm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParamSpec::clear_has_weight_norm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParamSpec::clear_weight_norm() {
  weight_norm_ = 0;
  clear_has_weight_norm();
}
inline float ParamSpec::weight_norm() const {
  return weight_norm_;
}
inline void ParamSpec::set_weight_norm(float value) {
  set_has_weight_norm();
  weight_norm_ = value;
}

// optional float weight_penalty = 4 [default = 0];
inline bool ParamSpec::has_weight_penalty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParamSpec::set_has_weight_penalty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParamSpec::clear_has_weight_penalty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParamSpec::clear_weight_penalty() {
  weight_penalty_ = 0;
  clear_has_weight_penalty();
}
inline float ParamSpec::weight_penalty() const {
  return weight_penalty_;
}
inline void ParamSpec::set_weight_penalty(float value) {
  set_has_weight_penalty();
  weight_penalty_ = value;
}

// -------------------------------------------------------------------

// LayerProp

// optional float loss_weight = 2 [default = 0];
inline bool LayerProp::has_loss_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerProp::set_has_loss_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerProp::clear_has_loss_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerProp::clear_loss_weight() {
  loss_weight_ = 0;
  clear_has_loss_weight();
}
inline float LayerProp::loss_weight() const {
  return loss_weight_;
}
inline void LayerProp::set_loss_weight(float value) {
  set_has_loss_weight();
  loss_weight_ = value;
}

// optional bool need_backward = 3 [default = true];
inline bool LayerProp::has_need_backward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerProp::set_has_need_backward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerProp::clear_has_need_backward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerProp::clear_need_backward() {
  need_backward_ = true;
  clear_has_need_backward();
}
inline bool LayerProp::need_backward() const {
  return need_backward_;
}
inline void LayerProp::set_need_backward(bool value) {
  set_has_need_backward();
  need_backward_ = value;
}

// optional float sec_loss_weight = 4 [default = 0];
inline bool LayerProp::has_sec_loss_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerProp::set_has_sec_loss_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerProp::clear_has_sec_loss_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerProp::clear_sec_loss_weight() {
  sec_loss_weight_ = 0;
  clear_has_sec_loss_weight();
}
inline float LayerProp::sec_loss_weight() const {
  return sec_loss_weight_;
}
inline void LayerProp::set_sec_loss_weight(float value) {
  set_has_sec_loss_weight();
  sec_loss_weight_ = value;
}

// optional float norm_value = 5 [default = 1];
inline bool LayerProp::has_norm_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerProp::set_has_norm_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerProp::clear_has_norm_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerProp::clear_norm_value() {
  norm_value_ = 1;
  clear_has_norm_value();
}
inline float LayerProp::norm_value() const {
  return norm_value_;
}
inline void LayerProp::set_norm_value(float value) {
  set_has_norm_value();
  norm_value_ = value;
}

// -------------------------------------------------------------------

// LayerParameter

// optional string name = 1;
inline bool LayerParameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerParameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerParameter::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LayerParameter::name() const {
  return *name_;
}
inline void LayerParameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerParameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerParameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LayerParameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerParameter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 2;
inline bool LayerParameter::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerParameter::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerParameter::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& LayerParameter::type() const {
  return *type_;
}
inline void LayerParameter::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LayerParameter::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LayerParameter::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* LayerParameter::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerParameter::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string bottom = 3;
inline int LayerParameter::bottom_size() const {
  return bottom_.size();
}
inline void LayerParameter::clear_bottom() {
  bottom_.Clear();
}
inline const ::std::string& LayerParameter::bottom(int index) const {
  return bottom_.Get(index);
}
inline ::std::string* LayerParameter::mutable_bottom(int index) {
  return bottom_.Mutable(index);
}
inline void LayerParameter::set_bottom(int index, const ::std::string& value) {
  bottom_.Mutable(index)->assign(value);
}
inline void LayerParameter::set_bottom(int index, const char* value) {
  bottom_.Mutable(index)->assign(value);
}
inline void LayerParameter::set_bottom(int index, const char* value, size_t size) {
  bottom_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::add_bottom() {
  return bottom_.Add();
}
inline void LayerParameter::add_bottom(const ::std::string& value) {
  bottom_.Add()->assign(value);
}
inline void LayerParameter::add_bottom(const char* value) {
  bottom_.Add()->assign(value);
}
inline void LayerParameter::add_bottom(const char* value, size_t size) {
  bottom_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LayerParameter::bottom() const {
  return bottom_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LayerParameter::mutable_bottom() {
  return &bottom_;
}

// repeated string top = 4;
inline int LayerParameter::top_size() const {
  return top_.size();
}
inline void LayerParameter::clear_top() {
  top_.Clear();
}
inline const ::std::string& LayerParameter::top(int index) const {
  return top_.Get(index);
}
inline ::std::string* LayerParameter::mutable_top(int index) {
  return top_.Mutable(index);
}
inline void LayerParameter::set_top(int index, const ::std::string& value) {
  top_.Mutable(index)->assign(value);
}
inline void LayerParameter::set_top(int index, const char* value) {
  top_.Mutable(index)->assign(value);
}
inline void LayerParameter::set_top(int index, const char* value, size_t size) {
  top_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::add_top() {
  return top_.Add();
}
inline void LayerParameter::add_top(const ::std::string& value) {
  top_.Add()->assign(value);
}
inline void LayerParameter::add_top(const char* value) {
  top_.Add()->assign(value);
}
inline void LayerParameter::add_top(const char* value, size_t size) {
  top_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LayerParameter::top() const {
  return top_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LayerParameter::mutable_top() {
  return &top_;
}

// repeated int32 bottom_flow = 101;
inline int LayerParameter::bottom_flow_size() const {
  return bottom_flow_.size();
}
inline void LayerParameter::clear_bottom_flow() {
  bottom_flow_.Clear();
}
inline ::google::protobuf::int32 LayerParameter::bottom_flow(int index) const {
  return bottom_flow_.Get(index);
}
inline void LayerParameter::set_bottom_flow(int index, ::google::protobuf::int32 value) {
  bottom_flow_.Set(index, value);
}
inline void LayerParameter::add_bottom_flow(::google::protobuf::int32 value) {
  bottom_flow_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LayerParameter::bottom_flow() const {
  return bottom_flow_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LayerParameter::mutable_bottom_flow() {
  return &bottom_flow_;
}

// repeated int32 top_flow = 102;
inline int LayerParameter::top_flow_size() const {
  return top_flow_.size();
}
inline void LayerParameter::clear_top_flow() {
  top_flow_.Clear();
}
inline ::google::protobuf::int32 LayerParameter::top_flow(int index) const {
  return top_flow_.Get(index);
}
inline void LayerParameter::set_top_flow(int index, ::google::protobuf::int32 value) {
  top_flow_.Set(index, value);
}
inline void LayerParameter::add_top_flow(::google::protobuf::int32 value) {
  top_flow_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LayerParameter::top_flow() const {
  return top_flow_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LayerParameter::mutable_top_flow() {
  return &top_flow_;
}

// optional .caffe.LayerProp include = 5;
inline bool LayerParameter::has_include() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerParameter::set_has_include() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayerParameter::clear_has_include() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayerParameter::clear_include() {
  if (include_ != NULL) include_->::caffe::LayerProp::Clear();
  clear_has_include();
}
inline const ::caffe::LayerProp& LayerParameter::include() const {
  return include_ != NULL ? *include_ : *default_instance_->include_;
}
inline ::caffe::LayerProp* LayerParameter::mutable_include() {
  set_has_include();
  if (include_ == NULL) include_ = new ::caffe::LayerProp;
  return include_;
}
inline ::caffe::LayerProp* LayerParameter::release_include() {
  clear_has_include();
  ::caffe::LayerProp* temp = include_;
  include_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_include(::caffe::LayerProp* include) {
  delete include_;
  include_ = include;
  if (include) {
    set_has_include();
  } else {
    clear_has_include();
  }
}

// repeated .caffe.ParamSpec param = 6;
inline int LayerParameter::param_size() const {
  return param_.size();
}
inline void LayerParameter::clear_param() {
  param_.Clear();
}
inline const ::caffe::ParamSpec& LayerParameter::param(int index) const {
  return param_.Get(index);
}
inline ::caffe::ParamSpec* LayerParameter::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::caffe::ParamSpec* LayerParameter::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe::ParamSpec >&
LayerParameter::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe::ParamSpec >*
LayerParameter::mutable_param() {
  return &param_;
}

// repeated .caffe.BlobProto blobs = 7;
inline int LayerParameter::blobs_size() const {
  return blobs_.size();
}
inline void LayerParameter::clear_blobs() {
  blobs_.Clear();
}
inline const ::caffe::BlobProto& LayerParameter::blobs(int index) const {
  return blobs_.Get(index);
}
inline ::caffe::BlobProto* LayerParameter::mutable_blobs(int index) {
  return blobs_.Mutable(index);
}
inline ::caffe::BlobProto* LayerParameter::add_blobs() {
  return blobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >&
LayerParameter::blobs() const {
  return blobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >*
LayerParameter::mutable_blobs() {
  return &blobs_;
}

// repeated .caffe.LayerParameter branch = 8;
inline int LayerParameter::branch_size() const {
  return branch_.size();
}
inline void LayerParameter::clear_branch() {
  branch_.Clear();
}
inline const ::caffe::LayerParameter& LayerParameter::branch(int index) const {
  return branch_.Get(index);
}
inline ::caffe::LayerParameter* LayerParameter::mutable_branch(int index) {
  return branch_.Mutable(index);
}
inline ::caffe::LayerParameter* LayerParameter::add_branch() {
  return branch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >&
LayerParameter::branch() const {
  return branch_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >*
LayerParameter::mutable_branch() {
  return &branch_;
}

// optional string bind_key = 9;
inline bool LayerParameter::has_bind_key() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LayerParameter::set_has_bind_key() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LayerParameter::clear_has_bind_key() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LayerParameter::clear_bind_key() {
  if (bind_key_ != &::google::protobuf::internal::kEmptyString) {
    bind_key_->clear();
  }
  clear_has_bind_key();
}
inline const ::std::string& LayerParameter::bind_key() const {
  return *bind_key_;
}
inline void LayerParameter::set_bind_key(const ::std::string& value) {
  set_has_bind_key();
  if (bind_key_ == &::google::protobuf::internal::kEmptyString) {
    bind_key_ = new ::std::string;
  }
  bind_key_->assign(value);
}
inline void LayerParameter::set_bind_key(const char* value) {
  set_has_bind_key();
  if (bind_key_ == &::google::protobuf::internal::kEmptyString) {
    bind_key_ = new ::std::string;
  }
  bind_key_->assign(value);
}
inline void LayerParameter::set_bind_key(const char* value, size_t size) {
  set_has_bind_key();
  if (bind_key_ == &::google::protobuf::internal::kEmptyString) {
    bind_key_ = new ::std::string;
  }
  bind_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::mutable_bind_key() {
  set_has_bind_key();
  if (bind_key_ == &::google::protobuf::internal::kEmptyString) {
    bind_key_ = new ::std::string;
  }
  return bind_key_;
}
inline ::std::string* LayerParameter::release_bind_key() {
  clear_has_bind_key();
  if (bind_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bind_key_;
    bind_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerParameter::set_allocated_bind_key(::std::string* bind_key) {
  if (bind_key_ != &::google::protobuf::internal::kEmptyString) {
    delete bind_key_;
  }
  if (bind_key) {
    set_has_bind_key();
    bind_key_ = bind_key;
  } else {
    clear_has_bind_key();
    bind_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bind_value = 10;
inline bool LayerParameter::has_bind_value() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LayerParameter::set_has_bind_value() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LayerParameter::clear_has_bind_value() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LayerParameter::clear_bind_value() {
  if (bind_value_ != &::google::protobuf::internal::kEmptyString) {
    bind_value_->clear();
  }
  clear_has_bind_value();
}
inline const ::std::string& LayerParameter::bind_value() const {
  return *bind_value_;
}
inline void LayerParameter::set_bind_value(const ::std::string& value) {
  set_has_bind_value();
  if (bind_value_ == &::google::protobuf::internal::kEmptyString) {
    bind_value_ = new ::std::string;
  }
  bind_value_->assign(value);
}
inline void LayerParameter::set_bind_value(const char* value) {
  set_has_bind_value();
  if (bind_value_ == &::google::protobuf::internal::kEmptyString) {
    bind_value_ = new ::std::string;
  }
  bind_value_->assign(value);
}
inline void LayerParameter::set_bind_value(const char* value, size_t size) {
  set_has_bind_value();
  if (bind_value_ == &::google::protobuf::internal::kEmptyString) {
    bind_value_ = new ::std::string;
  }
  bind_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParameter::mutable_bind_value() {
  set_has_bind_value();
  if (bind_value_ == &::google::protobuf::internal::kEmptyString) {
    bind_value_ = new ::std::string;
  }
  return bind_value_;
}
inline ::std::string* LayerParameter::release_bind_value() {
  clear_has_bind_value();
  if (bind_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bind_value_;
    bind_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerParameter::set_allocated_bind_value(::std::string* bind_value) {
  if (bind_value_ != &::google::protobuf::internal::kEmptyString) {
    delete bind_value_;
  }
  if (bind_value) {
    set_has_bind_value();
    bind_value_ = bind_value;
  } else {
    clear_has_bind_value();
    bind_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe.DataParameter data_param = 25;
inline bool LayerParameter::has_data_param() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LayerParameter::set_has_data_param() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LayerParameter::clear_has_data_param() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LayerParameter::clear_data_param() {
  if (data_param_ != NULL) data_param_->::caffe::DataParameter::Clear();
  clear_has_data_param();
}
inline const ::caffe::DataParameter& LayerParameter::data_param() const {
  return data_param_ != NULL ? *data_param_ : *default_instance_->data_param_;
}
inline ::caffe::DataParameter* LayerParameter::mutable_data_param() {
  set_has_data_param();
  if (data_param_ == NULL) data_param_ = new ::caffe::DataParameter;
  return data_param_;
}
inline ::caffe::DataParameter* LayerParameter::release_data_param() {
  clear_has_data_param();
  ::caffe::DataParameter* temp = data_param_;
  data_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_data_param(::caffe::DataParameter* data_param) {
  delete data_param_;
  data_param_ = data_param;
  if (data_param) {
    set_has_data_param();
  } else {
    clear_has_data_param();
  }
}

// optional .caffe.TransformationParameter transform_param = 26;
inline bool LayerParameter::has_transform_param() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LayerParameter::set_has_transform_param() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LayerParameter::clear_has_transform_param() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LayerParameter::clear_transform_param() {
  if (transform_param_ != NULL) transform_param_->::caffe::TransformationParameter::Clear();
  clear_has_transform_param();
}
inline const ::caffe::TransformationParameter& LayerParameter::transform_param() const {
  return transform_param_ != NULL ? *transform_param_ : *default_instance_->transform_param_;
}
inline ::caffe::TransformationParameter* LayerParameter::mutable_transform_param() {
  set_has_transform_param();
  if (transform_param_ == NULL) transform_param_ = new ::caffe::TransformationParameter;
  return transform_param_;
}
inline ::caffe::TransformationParameter* LayerParameter::release_transform_param() {
  clear_has_transform_param();
  ::caffe::TransformationParameter* temp = transform_param_;
  transform_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_transform_param(::caffe::TransformationParameter* transform_param) {
  delete transform_param_;
  transform_param_ = transform_param;
  if (transform_param) {
    set_has_transform_param();
  } else {
    clear_has_transform_param();
  }
}

// optional .caffe.ConvolutionParameter convolution_param = 27;
inline bool LayerParameter::has_convolution_param() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LayerParameter::set_has_convolution_param() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LayerParameter::clear_has_convolution_param() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LayerParameter::clear_convolution_param() {
  if (convolution_param_ != NULL) convolution_param_->::caffe::ConvolutionParameter::Clear();
  clear_has_convolution_param();
}
inline const ::caffe::ConvolutionParameter& LayerParameter::convolution_param() const {
  return convolution_param_ != NULL ? *convolution_param_ : *default_instance_->convolution_param_;
}
inline ::caffe::ConvolutionParameter* LayerParameter::mutable_convolution_param() {
  set_has_convolution_param();
  if (convolution_param_ == NULL) convolution_param_ = new ::caffe::ConvolutionParameter;
  return convolution_param_;
}
inline ::caffe::ConvolutionParameter* LayerParameter::release_convolution_param() {
  clear_has_convolution_param();
  ::caffe::ConvolutionParameter* temp = convolution_param_;
  convolution_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_convolution_param(::caffe::ConvolutionParameter* convolution_param) {
  delete convolution_param_;
  convolution_param_ = convolution_param;
  if (convolution_param) {
    set_has_convolution_param();
  } else {
    clear_has_convolution_param();
  }
}

// optional .caffe.LossParameter loss_param = 28;
inline bool LayerParameter::has_loss_param() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LayerParameter::set_has_loss_param() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LayerParameter::clear_has_loss_param() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LayerParameter::clear_loss_param() {
  if (loss_param_ != NULL) loss_param_->::caffe::LossParameter::Clear();
  clear_has_loss_param();
}
inline const ::caffe::LossParameter& LayerParameter::loss_param() const {
  return loss_param_ != NULL ? *loss_param_ : *default_instance_->loss_param_;
}
inline ::caffe::LossParameter* LayerParameter::mutable_loss_param() {
  set_has_loss_param();
  if (loss_param_ == NULL) loss_param_ = new ::caffe::LossParameter;
  return loss_param_;
}
inline ::caffe::LossParameter* LayerParameter::release_loss_param() {
  clear_has_loss_param();
  ::caffe::LossParameter* temp = loss_param_;
  loss_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_loss_param(::caffe::LossParameter* loss_param) {
  delete loss_param_;
  loss_param_ = loss_param;
  if (loss_param) {
    set_has_loss_param();
  } else {
    clear_has_loss_param();
  }
}

// optional .caffe.PoolingParameter pooling_param = 29;
inline bool LayerParameter::has_pooling_param() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LayerParameter::set_has_pooling_param() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LayerParameter::clear_has_pooling_param() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LayerParameter::clear_pooling_param() {
  if (pooling_param_ != NULL) pooling_param_->::caffe::PoolingParameter::Clear();
  clear_has_pooling_param();
}
inline const ::caffe::PoolingParameter& LayerParameter::pooling_param() const {
  return pooling_param_ != NULL ? *pooling_param_ : *default_instance_->pooling_param_;
}
inline ::caffe::PoolingParameter* LayerParameter::mutable_pooling_param() {
  set_has_pooling_param();
  if (pooling_param_ == NULL) pooling_param_ = new ::caffe::PoolingParameter;
  return pooling_param_;
}
inline ::caffe::PoolingParameter* LayerParameter::release_pooling_param() {
  clear_has_pooling_param();
  ::caffe::PoolingParameter* temp = pooling_param_;
  pooling_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_pooling_param(::caffe::PoolingParameter* pooling_param) {
  delete pooling_param_;
  pooling_param_ = pooling_param;
  if (pooling_param) {
    set_has_pooling_param();
  } else {
    clear_has_pooling_param();
  }
}

// optional .caffe.InnerProductParameter inner_product_param = 30;
inline bool LayerParameter::has_inner_product_param() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LayerParameter::set_has_inner_product_param() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LayerParameter::clear_has_inner_product_param() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LayerParameter::clear_inner_product_param() {
  if (inner_product_param_ != NULL) inner_product_param_->::caffe::InnerProductParameter::Clear();
  clear_has_inner_product_param();
}
inline const ::caffe::InnerProductParameter& LayerParameter::inner_product_param() const {
  return inner_product_param_ != NULL ? *inner_product_param_ : *default_instance_->inner_product_param_;
}
inline ::caffe::InnerProductParameter* LayerParameter::mutable_inner_product_param() {
  set_has_inner_product_param();
  if (inner_product_param_ == NULL) inner_product_param_ = new ::caffe::InnerProductParameter;
  return inner_product_param_;
}
inline ::caffe::InnerProductParameter* LayerParameter::release_inner_product_param() {
  clear_has_inner_product_param();
  ::caffe::InnerProductParameter* temp = inner_product_param_;
  inner_product_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_inner_product_param(::caffe::InnerProductParameter* inner_product_param) {
  delete inner_product_param_;
  inner_product_param_ = inner_product_param;
  if (inner_product_param) {
    set_has_inner_product_param();
  } else {
    clear_has_inner_product_param();
  }
}

// optional .caffe.BatchNormParameter batch_norm_param = 31;
inline bool LayerParameter::has_batch_norm_param() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LayerParameter::set_has_batch_norm_param() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LayerParameter::clear_has_batch_norm_param() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LayerParameter::clear_batch_norm_param() {
  if (batch_norm_param_ != NULL) batch_norm_param_->::caffe::BatchNormParameter::Clear();
  clear_has_batch_norm_param();
}
inline const ::caffe::BatchNormParameter& LayerParameter::batch_norm_param() const {
  return batch_norm_param_ != NULL ? *batch_norm_param_ : *default_instance_->batch_norm_param_;
}
inline ::caffe::BatchNormParameter* LayerParameter::mutable_batch_norm_param() {
  set_has_batch_norm_param();
  if (batch_norm_param_ == NULL) batch_norm_param_ = new ::caffe::BatchNormParameter;
  return batch_norm_param_;
}
inline ::caffe::BatchNormParameter* LayerParameter::release_batch_norm_param() {
  clear_has_batch_norm_param();
  ::caffe::BatchNormParameter* temp = batch_norm_param_;
  batch_norm_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_batch_norm_param(::caffe::BatchNormParameter* batch_norm_param) {
  delete batch_norm_param_;
  batch_norm_param_ = batch_norm_param;
  if (batch_norm_param) {
    set_has_batch_norm_param();
  } else {
    clear_has_batch_norm_param();
  }
}

// optional .caffe.ShortcutParameter shortcut_param = 32;
inline bool LayerParameter::has_shortcut_param() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LayerParameter::set_has_shortcut_param() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LayerParameter::clear_has_shortcut_param() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LayerParameter::clear_shortcut_param() {
  if (shortcut_param_ != NULL) shortcut_param_->::caffe::ShortcutParameter::Clear();
  clear_has_shortcut_param();
}
inline const ::caffe::ShortcutParameter& LayerParameter::shortcut_param() const {
  return shortcut_param_ != NULL ? *shortcut_param_ : *default_instance_->shortcut_param_;
}
inline ::caffe::ShortcutParameter* LayerParameter::mutable_shortcut_param() {
  set_has_shortcut_param();
  if (shortcut_param_ == NULL) shortcut_param_ = new ::caffe::ShortcutParameter;
  return shortcut_param_;
}
inline ::caffe::ShortcutParameter* LayerParameter::release_shortcut_param() {
  clear_has_shortcut_param();
  ::caffe::ShortcutParameter* temp = shortcut_param_;
  shortcut_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_shortcut_param(::caffe::ShortcutParameter* shortcut_param) {
  delete shortcut_param_;
  shortcut_param_ = shortcut_param;
  if (shortcut_param) {
    set_has_shortcut_param();
  } else {
    clear_has_shortcut_param();
  }
}

// optional .caffe.AccuracyParameter accuracy_param = 33;
inline bool LayerParameter::has_accuracy_param() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LayerParameter::set_has_accuracy_param() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LayerParameter::clear_has_accuracy_param() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LayerParameter::clear_accuracy_param() {
  if (accuracy_param_ != NULL) accuracy_param_->::caffe::AccuracyParameter::Clear();
  clear_has_accuracy_param();
}
inline const ::caffe::AccuracyParameter& LayerParameter::accuracy_param() const {
  return accuracy_param_ != NULL ? *accuracy_param_ : *default_instance_->accuracy_param_;
}
inline ::caffe::AccuracyParameter* LayerParameter::mutable_accuracy_param() {
  set_has_accuracy_param();
  if (accuracy_param_ == NULL) accuracy_param_ = new ::caffe::AccuracyParameter;
  return accuracy_param_;
}
inline ::caffe::AccuracyParameter* LayerParameter::release_accuracy_param() {
  clear_has_accuracy_param();
  ::caffe::AccuracyParameter* temp = accuracy_param_;
  accuracy_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_accuracy_param(::caffe::AccuracyParameter* accuracy_param) {
  delete accuracy_param_;
  accuracy_param_ = accuracy_param;
  if (accuracy_param) {
    set_has_accuracy_param();
  } else {
    clear_has_accuracy_param();
  }
}

// optional .caffe.NormalizeParameter norm_param = 34;
inline bool LayerParameter::has_norm_param() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LayerParameter::set_has_norm_param() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LayerParameter::clear_has_norm_param() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LayerParameter::clear_norm_param() {
  if (norm_param_ != NULL) norm_param_->::caffe::NormalizeParameter::Clear();
  clear_has_norm_param();
}
inline const ::caffe::NormalizeParameter& LayerParameter::norm_param() const {
  return norm_param_ != NULL ? *norm_param_ : *default_instance_->norm_param_;
}
inline ::caffe::NormalizeParameter* LayerParameter::mutable_norm_param() {
  set_has_norm_param();
  if (norm_param_ == NULL) norm_param_ = new ::caffe::NormalizeParameter;
  return norm_param_;
}
inline ::caffe::NormalizeParameter* LayerParameter::release_norm_param() {
  clear_has_norm_param();
  ::caffe::NormalizeParameter* temp = norm_param_;
  norm_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_norm_param(::caffe::NormalizeParameter* norm_param) {
  delete norm_param_;
  norm_param_ = norm_param;
  if (norm_param) {
    set_has_norm_param();
  } else {
    clear_has_norm_param();
  }
}

// optional .caffe.ContextPoolingParameter context_pooling_param = 35;
inline bool LayerParameter::has_context_pooling_param() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LayerParameter::set_has_context_pooling_param() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LayerParameter::clear_has_context_pooling_param() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LayerParameter::clear_context_pooling_param() {
  if (context_pooling_param_ != NULL) context_pooling_param_->::caffe::ContextPoolingParameter::Clear();
  clear_has_context_pooling_param();
}
inline const ::caffe::ContextPoolingParameter& LayerParameter::context_pooling_param() const {
  return context_pooling_param_ != NULL ? *context_pooling_param_ : *default_instance_->context_pooling_param_;
}
inline ::caffe::ContextPoolingParameter* LayerParameter::mutable_context_pooling_param() {
  set_has_context_pooling_param();
  if (context_pooling_param_ == NULL) context_pooling_param_ = new ::caffe::ContextPoolingParameter;
  return context_pooling_param_;
}
inline ::caffe::ContextPoolingParameter* LayerParameter::release_context_pooling_param() {
  clear_has_context_pooling_param();
  ::caffe::ContextPoolingParameter* temp = context_pooling_param_;
  context_pooling_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_context_pooling_param(::caffe::ContextPoolingParameter* context_pooling_param) {
  delete context_pooling_param_;
  context_pooling_param_ = context_pooling_param;
  if (context_pooling_param) {
    set_has_context_pooling_param();
  } else {
    clear_has_context_pooling_param();
  }
}

// optional .caffe.CRFParameter crf_param = 36;
inline bool LayerParameter::has_crf_param() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void LayerParameter::set_has_crf_param() {
  _has_bits_[0] |= 0x00800000u;
}
inline void LayerParameter::clear_has_crf_param() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void LayerParameter::clear_crf_param() {
  if (crf_param_ != NULL) crf_param_->::caffe::CRFParameter::Clear();
  clear_has_crf_param();
}
inline const ::caffe::CRFParameter& LayerParameter::crf_param() const {
  return crf_param_ != NULL ? *crf_param_ : *default_instance_->crf_param_;
}
inline ::caffe::CRFParameter* LayerParameter::mutable_crf_param() {
  set_has_crf_param();
  if (crf_param_ == NULL) crf_param_ = new ::caffe::CRFParameter;
  return crf_param_;
}
inline ::caffe::CRFParameter* LayerParameter::release_crf_param() {
  clear_has_crf_param();
  ::caffe::CRFParameter* temp = crf_param_;
  crf_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_crf_param(::caffe::CRFParameter* crf_param) {
  delete crf_param_;
  crf_param_ = crf_param;
  if (crf_param) {
    set_has_crf_param();
  } else {
    clear_has_crf_param();
  }
}

// optional .caffe.EltwiseParameter eltwise_param = 37;
inline bool LayerParameter::has_eltwise_param() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void LayerParameter::set_has_eltwise_param() {
  _has_bits_[0] |= 0x01000000u;
}
inline void LayerParameter::clear_has_eltwise_param() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void LayerParameter::clear_eltwise_param() {
  if (eltwise_param_ != NULL) eltwise_param_->::caffe::EltwiseParameter::Clear();
  clear_has_eltwise_param();
}
inline const ::caffe::EltwiseParameter& LayerParameter::eltwise_param() const {
  return eltwise_param_ != NULL ? *eltwise_param_ : *default_instance_->eltwise_param_;
}
inline ::caffe::EltwiseParameter* LayerParameter::mutable_eltwise_param() {
  set_has_eltwise_param();
  if (eltwise_param_ == NULL) eltwise_param_ = new ::caffe::EltwiseParameter;
  return eltwise_param_;
}
inline ::caffe::EltwiseParameter* LayerParameter::release_eltwise_param() {
  clear_has_eltwise_param();
  ::caffe::EltwiseParameter* temp = eltwise_param_;
  eltwise_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_eltwise_param(::caffe::EltwiseParameter* eltwise_param) {
  delete eltwise_param_;
  eltwise_param_ = eltwise_param;
  if (eltwise_param) {
    set_has_eltwise_param();
  } else {
    clear_has_eltwise_param();
  }
}

// optional .caffe.ParseEvaluateParameter parse_evaluate_param = 38;
inline bool LayerParameter::has_parse_evaluate_param() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void LayerParameter::set_has_parse_evaluate_param() {
  _has_bits_[0] |= 0x02000000u;
}
inline void LayerParameter::clear_has_parse_evaluate_param() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void LayerParameter::clear_parse_evaluate_param() {
  if (parse_evaluate_param_ != NULL) parse_evaluate_param_->::caffe::ParseEvaluateParameter::Clear();
  clear_has_parse_evaluate_param();
}
inline const ::caffe::ParseEvaluateParameter& LayerParameter::parse_evaluate_param() const {
  return parse_evaluate_param_ != NULL ? *parse_evaluate_param_ : *default_instance_->parse_evaluate_param_;
}
inline ::caffe::ParseEvaluateParameter* LayerParameter::mutable_parse_evaluate_param() {
  set_has_parse_evaluate_param();
  if (parse_evaluate_param_ == NULL) parse_evaluate_param_ = new ::caffe::ParseEvaluateParameter;
  return parse_evaluate_param_;
}
inline ::caffe::ParseEvaluateParameter* LayerParameter::release_parse_evaluate_param() {
  clear_has_parse_evaluate_param();
  ::caffe::ParseEvaluateParameter* temp = parse_evaluate_param_;
  parse_evaluate_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_parse_evaluate_param(::caffe::ParseEvaluateParameter* parse_evaluate_param) {
  delete parse_evaluate_param_;
  parse_evaluate_param_ = parse_evaluate_param;
  if (parse_evaluate_param) {
    set_has_parse_evaluate_param();
  } else {
    clear_has_parse_evaluate_param();
  }
}

// optional .caffe.DropoutParameter dropout_param = 39;
inline bool LayerParameter::has_dropout_param() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void LayerParameter::set_has_dropout_param() {
  _has_bits_[0] |= 0x04000000u;
}
inline void LayerParameter::clear_has_dropout_param() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void LayerParameter::clear_dropout_param() {
  if (dropout_param_ != NULL) dropout_param_->::caffe::DropoutParameter::Clear();
  clear_has_dropout_param();
}
inline const ::caffe::DropoutParameter& LayerParameter::dropout_param() const {
  return dropout_param_ != NULL ? *dropout_param_ : *default_instance_->dropout_param_;
}
inline ::caffe::DropoutParameter* LayerParameter::mutable_dropout_param() {
  set_has_dropout_param();
  if (dropout_param_ == NULL) dropout_param_ = new ::caffe::DropoutParameter;
  return dropout_param_;
}
inline ::caffe::DropoutParameter* LayerParameter::release_dropout_param() {
  clear_has_dropout_param();
  ::caffe::DropoutParameter* temp = dropout_param_;
  dropout_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_dropout_param(::caffe::DropoutParameter* dropout_param) {
  delete dropout_param_;
  dropout_param_ = dropout_param;
  if (dropout_param) {
    set_has_dropout_param();
  } else {
    clear_has_dropout_param();
  }
}

// optional .caffe.InterpParameter interp_param = 40;
inline bool LayerParameter::has_interp_param() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void LayerParameter::set_has_interp_param() {
  _has_bits_[0] |= 0x08000000u;
}
inline void LayerParameter::clear_has_interp_param() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void LayerParameter::clear_interp_param() {
  if (interp_param_ != NULL) interp_param_->::caffe::InterpParameter::Clear();
  clear_has_interp_param();
}
inline const ::caffe::InterpParameter& LayerParameter::interp_param() const {
  return interp_param_ != NULL ? *interp_param_ : *default_instance_->interp_param_;
}
inline ::caffe::InterpParameter* LayerParameter::mutable_interp_param() {
  set_has_interp_param();
  if (interp_param_ == NULL) interp_param_ = new ::caffe::InterpParameter;
  return interp_param_;
}
inline ::caffe::InterpParameter* LayerParameter::release_interp_param() {
  clear_has_interp_param();
  ::caffe::InterpParameter* temp = interp_param_;
  interp_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_interp_param(::caffe::InterpParameter* interp_param) {
  delete interp_param_;
  interp_param_ = interp_param;
  if (interp_param) {
    set_has_interp_param();
  } else {
    clear_has_interp_param();
  }
}

// optional .caffe.SecParameter sec_param = 41;
inline bool LayerParameter::has_sec_param() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void LayerParameter::set_has_sec_param() {
  _has_bits_[0] |= 0x10000000u;
}
inline void LayerParameter::clear_has_sec_param() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void LayerParameter::clear_sec_param() {
  if (sec_param_ != NULL) sec_param_->::caffe::SecParameter::Clear();
  clear_has_sec_param();
}
inline const ::caffe::SecParameter& LayerParameter::sec_param() const {
  return sec_param_ != NULL ? *sec_param_ : *default_instance_->sec_param_;
}
inline ::caffe::SecParameter* LayerParameter::mutable_sec_param() {
  set_has_sec_param();
  if (sec_param_ == NULL) sec_param_ = new ::caffe::SecParameter;
  return sec_param_;
}
inline ::caffe::SecParameter* LayerParameter::release_sec_param() {
  clear_has_sec_param();
  ::caffe::SecParameter* temp = sec_param_;
  sec_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_sec_param(::caffe::SecParameter* sec_param) {
  delete sec_param_;
  sec_param_ = sec_param;
  if (sec_param) {
    set_has_sec_param();
  } else {
    clear_has_sec_param();
  }
}

// optional .caffe.NoiseParameter noise_param = 42;
inline bool LayerParameter::has_noise_param() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void LayerParameter::set_has_noise_param() {
  _has_bits_[0] |= 0x20000000u;
}
inline void LayerParameter::clear_has_noise_param() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void LayerParameter::clear_noise_param() {
  if (noise_param_ != NULL) noise_param_->::caffe::NoiseParameter::Clear();
  clear_has_noise_param();
}
inline const ::caffe::NoiseParameter& LayerParameter::noise_param() const {
  return noise_param_ != NULL ? *noise_param_ : *default_instance_->noise_param_;
}
inline ::caffe::NoiseParameter* LayerParameter::mutable_noise_param() {
  set_has_noise_param();
  if (noise_param_ == NULL) noise_param_ = new ::caffe::NoiseParameter;
  return noise_param_;
}
inline ::caffe::NoiseParameter* LayerParameter::release_noise_param() {
  clear_has_noise_param();
  ::caffe::NoiseParameter* temp = noise_param_;
  noise_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_noise_param(::caffe::NoiseParameter* noise_param) {
  delete noise_param_;
  noise_param_ = noise_param;
  if (noise_param) {
    set_has_noise_param();
  } else {
    clear_has_noise_param();
  }
}

// optional .caffe.ReLUParameter relu_param = 43;
inline bool LayerParameter::has_relu_param() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void LayerParameter::set_has_relu_param() {
  _has_bits_[0] |= 0x40000000u;
}
inline void LayerParameter::clear_has_relu_param() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void LayerParameter::clear_relu_param() {
  if (relu_param_ != NULL) relu_param_->::caffe::ReLUParameter::Clear();
  clear_has_relu_param();
}
inline const ::caffe::ReLUParameter& LayerParameter::relu_param() const {
  return relu_param_ != NULL ? *relu_param_ : *default_instance_->relu_param_;
}
inline ::caffe::ReLUParameter* LayerParameter::mutable_relu_param() {
  set_has_relu_param();
  if (relu_param_ == NULL) relu_param_ = new ::caffe::ReLUParameter;
  return relu_param_;
}
inline ::caffe::ReLUParameter* LayerParameter::release_relu_param() {
  clear_has_relu_param();
  ::caffe::ReLUParameter* temp = relu_param_;
  relu_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_relu_param(::caffe::ReLUParameter* relu_param) {
  delete relu_param_;
  relu_param_ = relu_param;
  if (relu_param) {
    set_has_relu_param();
  } else {
    clear_has_relu_param();
  }
}

// optional .caffe.BlobShape shape_param = 44;
inline bool LayerParameter::has_shape_param() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void LayerParameter::set_has_shape_param() {
  _has_bits_[0] |= 0x80000000u;
}
inline void LayerParameter::clear_has_shape_param() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void LayerParameter::clear_shape_param() {
  if (shape_param_ != NULL) shape_param_->::caffe::BlobShape::Clear();
  clear_has_shape_param();
}
inline const ::caffe::BlobShape& LayerParameter::shape_param() const {
  return shape_param_ != NULL ? *shape_param_ : *default_instance_->shape_param_;
}
inline ::caffe::BlobShape* LayerParameter::mutable_shape_param() {
  set_has_shape_param();
  if (shape_param_ == NULL) shape_param_ = new ::caffe::BlobShape;
  return shape_param_;
}
inline ::caffe::BlobShape* LayerParameter::release_shape_param() {
  clear_has_shape_param();
  ::caffe::BlobShape* temp = shape_param_;
  shape_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_shape_param(::caffe::BlobShape* shape_param) {
  delete shape_param_;
  shape_param_ = shape_param;
  if (shape_param) {
    set_has_shape_param();
  } else {
    clear_has_shape_param();
  }
}

// optional .caffe.ConcatParameter concat_param = 45;
inline bool LayerParameter::has_concat_param() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void LayerParameter::set_has_concat_param() {
  _has_bits_[1] |= 0x00000001u;
}
inline void LayerParameter::clear_has_concat_param() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void LayerParameter::clear_concat_param() {
  if (concat_param_ != NULL) concat_param_->::caffe::ConcatParameter::Clear();
  clear_has_concat_param();
}
inline const ::caffe::ConcatParameter& LayerParameter::concat_param() const {
  return concat_param_ != NULL ? *concat_param_ : *default_instance_->concat_param_;
}
inline ::caffe::ConcatParameter* LayerParameter::mutable_concat_param() {
  set_has_concat_param();
  if (concat_param_ == NULL) concat_param_ = new ::caffe::ConcatParameter;
  return concat_param_;
}
inline ::caffe::ConcatParameter* LayerParameter::release_concat_param() {
  clear_has_concat_param();
  ::caffe::ConcatParameter* temp = concat_param_;
  concat_param_ = NULL;
  return temp;
}
inline void LayerParameter::set_allocated_concat_param(::caffe::ConcatParameter* concat_param) {
  delete concat_param_;
  concat_param_ = concat_param;
  if (concat_param) {
    set_has_concat_param();
  } else {
    clear_has_concat_param();
  }
}

// repeated .caffe.BlobProto first_moment = 46;
inline int LayerParameter::first_moment_size() const {
  return first_moment_.size();
}
inline void LayerParameter::clear_first_moment() {
  first_moment_.Clear();
}
inline const ::caffe::BlobProto& LayerParameter::first_moment(int index) const {
  return first_moment_.Get(index);
}
inline ::caffe::BlobProto* LayerParameter::mutable_first_moment(int index) {
  return first_moment_.Mutable(index);
}
inline ::caffe::BlobProto* LayerParameter::add_first_moment() {
  return first_moment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >&
LayerParameter::first_moment() const {
  return first_moment_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >*
LayerParameter::mutable_first_moment() {
  return &first_moment_;
}

// repeated .caffe.BlobProto second_moment = 47;
inline int LayerParameter::second_moment_size() const {
  return second_moment_.size();
}
inline void LayerParameter::clear_second_moment() {
  second_moment_.Clear();
}
inline const ::caffe::BlobProto& LayerParameter::second_moment(int index) const {
  return second_moment_.Get(index);
}
inline ::caffe::BlobProto* LayerParameter::mutable_second_moment(int index) {
  return second_moment_.Mutable(index);
}
inline ::caffe::BlobProto* LayerParameter::add_second_moment() {
  return second_moment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >&
LayerParameter::second_moment() const {
  return second_moment_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe::BlobProto >*
LayerParameter::mutable_second_moment() {
  return &second_moment_;
}

// repeated int32 bottom_index = 48;
inline int LayerParameter::bottom_index_size() const {
  return bottom_index_.size();
}
inline void LayerParameter::clear_bottom_index() {
  bottom_index_.Clear();
}
inline ::google::protobuf::int32 LayerParameter::bottom_index(int index) const {
  return bottom_index_.Get(index);
}
inline void LayerParameter::set_bottom_index(int index, ::google::protobuf::int32 value) {
  bottom_index_.Set(index, value);
}
inline void LayerParameter::add_bottom_index(::google::protobuf::int32 value) {
  bottom_index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LayerParameter::bottom_index() const {
  return bottom_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LayerParameter::mutable_bottom_index() {
  return &bottom_index_;
}

// -------------------------------------------------------------------

// ConcatParameter

// repeated int32 channels = 1;
inline int ConcatParameter::channels_size() const {
  return channels_.size();
}
inline void ConcatParameter::clear_channels() {
  channels_.Clear();
}
inline ::google::protobuf::int32 ConcatParameter::channels(int index) const {
  return channels_.Get(index);
}
inline void ConcatParameter::set_channels(int index, ::google::protobuf::int32 value) {
  channels_.Set(index, value);
}
inline void ConcatParameter::add_channels(::google::protobuf::int32 value) {
  channels_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConcatParameter::channels() const {
  return channels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConcatParameter::mutable_channels() {
  return &channels_;
}

// -------------------------------------------------------------------

// ReLUParameter

// optional float negative_slope = 1 [default = 0];
inline bool ReLUParameter::has_negative_slope() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReLUParameter::set_has_negative_slope() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReLUParameter::clear_has_negative_slope() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReLUParameter::clear_negative_slope() {
  negative_slope_ = 0;
  clear_has_negative_slope();
}
inline float ReLUParameter::negative_slope() const {
  return negative_slope_;
}
inline void ReLUParameter::set_negative_slope(float value) {
  set_has_negative_slope();
  negative_slope_ = value;
}

// -------------------------------------------------------------------

// NoiseParameter

// optional int32 num = 1;
inline bool NoiseParameter::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NoiseParameter::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NoiseParameter::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NoiseParameter::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 NoiseParameter::num() const {
  return num_;
}
inline void NoiseParameter::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 channels = 2;
inline bool NoiseParameter::has_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NoiseParameter::set_has_channels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NoiseParameter::clear_has_channels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NoiseParameter::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 NoiseParameter::channels() const {
  return channels_;
}
inline void NoiseParameter::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 classes = 3;
inline bool NoiseParameter::has_classes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NoiseParameter::set_has_classes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NoiseParameter::clear_has_classes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NoiseParameter::clear_classes() {
  classes_ = 0;
  clear_has_classes();
}
inline ::google::protobuf::int32 NoiseParameter::classes() const {
  return classes_;
}
inline void NoiseParameter::set_classes(::google::protobuf::int32 value) {
  set_has_classes();
  classes_ = value;
}

// -------------------------------------------------------------------

// SecParameter

// optional string sec_feature = 1;
inline bool SecParameter::has_sec_feature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecParameter::set_has_sec_feature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecParameter::clear_has_sec_feature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecParameter::clear_sec_feature() {
  if (sec_feature_ != &::google::protobuf::internal::kEmptyString) {
    sec_feature_->clear();
  }
  clear_has_sec_feature();
}
inline const ::std::string& SecParameter::sec_feature() const {
  return *sec_feature_;
}
inline void SecParameter::set_sec_feature(const ::std::string& value) {
  set_has_sec_feature();
  if (sec_feature_ == &::google::protobuf::internal::kEmptyString) {
    sec_feature_ = new ::std::string;
  }
  sec_feature_->assign(value);
}
inline void SecParameter::set_sec_feature(const char* value) {
  set_has_sec_feature();
  if (sec_feature_ == &::google::protobuf::internal::kEmptyString) {
    sec_feature_ = new ::std::string;
  }
  sec_feature_->assign(value);
}
inline void SecParameter::set_sec_feature(const char* value, size_t size) {
  set_has_sec_feature();
  if (sec_feature_ == &::google::protobuf::internal::kEmptyString) {
    sec_feature_ = new ::std::string;
  }
  sec_feature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecParameter::mutable_sec_feature() {
  set_has_sec_feature();
  if (sec_feature_ == &::google::protobuf::internal::kEmptyString) {
    sec_feature_ = new ::std::string;
  }
  return sec_feature_;
}
inline ::std::string* SecParameter::release_sec_feature() {
  clear_has_sec_feature();
  if (sec_feature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sec_feature_;
    sec_feature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecParameter::set_allocated_sec_feature(::std::string* sec_feature) {
  if (sec_feature_ != &::google::protobuf::internal::kEmptyString) {
    delete sec_feature_;
  }
  if (sec_feature) {
    set_has_sec_feature();
    sec_feature_ = sec_feature;
  } else {
    clear_has_sec_feature();
    sec_feature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InterpParameter

// optional float interp_ratio = 1;
inline bool InterpParameter::has_interp_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterpParameter::set_has_interp_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterpParameter::clear_has_interp_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterpParameter::clear_interp_ratio() {
  interp_ratio_ = 0;
  clear_has_interp_ratio();
}
inline float InterpParameter::interp_ratio() const {
  return interp_ratio_;
}
inline void InterpParameter::set_interp_ratio(float value) {
  set_has_interp_ratio();
  interp_ratio_ = value;
}

// optional int32 stride = 2;
inline bool InterpParameter::has_stride() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterpParameter::set_has_stride() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterpParameter::clear_has_stride() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterpParameter::clear_stride() {
  stride_ = 0;
  clear_has_stride();
}
inline ::google::protobuf::int32 InterpParameter::stride() const {
  return stride_;
}
inline void InterpParameter::set_stride(::google::protobuf::int32 value) {
  set_has_stride();
  stride_ = value;
}

// optional int32 kernel_size = 3;
inline bool InterpParameter::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InterpParameter::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InterpParameter::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InterpParameter::clear_kernel_size() {
  kernel_size_ = 0;
  clear_has_kernel_size();
}
inline ::google::protobuf::int32 InterpParameter::kernel_size() const {
  return kernel_size_;
}
inline void InterpParameter::set_kernel_size(::google::protobuf::int32 value) {
  set_has_kernel_size();
  kernel_size_ = value;
}

// optional int32 num_classes = 4;
inline bool InterpParameter::has_num_classes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InterpParameter::set_has_num_classes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InterpParameter::clear_has_num_classes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InterpParameter::clear_num_classes() {
  num_classes_ = 0;
  clear_has_num_classes();
}
inline ::google::protobuf::int32 InterpParameter::num_classes() const {
  return num_classes_;
}
inline void InterpParameter::set_num_classes(::google::protobuf::int32 value) {
  set_has_num_classes();
  num_classes_ = value;
}

// -------------------------------------------------------------------

// DropoutParameter

// optional float dropout_ratio = 1 [default = 0.5];
inline bool DropoutParameter::has_dropout_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropoutParameter::set_has_dropout_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropoutParameter::clear_has_dropout_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropoutParameter::clear_dropout_ratio() {
  dropout_ratio_ = 0.5f;
  clear_has_dropout_ratio();
}
inline float DropoutParameter::dropout_ratio() const {
  return dropout_ratio_;
}
inline void DropoutParameter::set_dropout_ratio(float value) {
  set_has_dropout_ratio();
  dropout_ratio_ = value;
}

// -------------------------------------------------------------------

// ParseEvaluateParameter

// optional int32 num_labels = 1;
inline bool ParseEvaluateParameter::has_num_labels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParseEvaluateParameter::set_has_num_labels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParseEvaluateParameter::clear_has_num_labels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParseEvaluateParameter::clear_num_labels() {
  num_labels_ = 0;
  clear_has_num_labels();
}
inline ::google::protobuf::int32 ParseEvaluateParameter::num_labels() const {
  return num_labels_;
}
inline void ParseEvaluateParameter::set_num_labels(::google::protobuf::int32 value) {
  set_has_num_labels();
  num_labels_ = value;
}

// repeated int32 ignore_label = 2;
inline int ParseEvaluateParameter::ignore_label_size() const {
  return ignore_label_.size();
}
inline void ParseEvaluateParameter::clear_ignore_label() {
  ignore_label_.Clear();
}
inline ::google::protobuf::int32 ParseEvaluateParameter::ignore_label(int index) const {
  return ignore_label_.Get(index);
}
inline void ParseEvaluateParameter::set_ignore_label(int index, ::google::protobuf::int32 value) {
  ignore_label_.Set(index, value);
}
inline void ParseEvaluateParameter::add_ignore_label(::google::protobuf::int32 value) {
  ignore_label_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ParseEvaluateParameter::ignore_label() const {
  return ignore_label_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ParseEvaluateParameter::mutable_ignore_label() {
  return &ignore_label_;
}

// -------------------------------------------------------------------

// EltwiseParameter

// optional string operation = 1 [default = "sum"];
inline bool EltwiseParameter::has_operation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EltwiseParameter::set_has_operation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EltwiseParameter::clear_has_operation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EltwiseParameter::clear_operation() {
  if (operation_ != _default_operation_) {
    operation_->assign(*_default_operation_);
  }
  clear_has_operation();
}
inline const ::std::string& EltwiseParameter::operation() const {
  return *operation_;
}
inline void EltwiseParameter::set_operation(const ::std::string& value) {
  set_has_operation();
  if (operation_ == _default_operation_) {
    operation_ = new ::std::string;
  }
  operation_->assign(value);
}
inline void EltwiseParameter::set_operation(const char* value) {
  set_has_operation();
  if (operation_ == _default_operation_) {
    operation_ = new ::std::string;
  }
  operation_->assign(value);
}
inline void EltwiseParameter::set_operation(const char* value, size_t size) {
  set_has_operation();
  if (operation_ == _default_operation_) {
    operation_ = new ::std::string;
  }
  operation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EltwiseParameter::mutable_operation() {
  set_has_operation();
  if (operation_ == _default_operation_) {
    operation_ = new ::std::string(*_default_operation_);
  }
  return operation_;
}
inline ::std::string* EltwiseParameter::release_operation() {
  clear_has_operation();
  if (operation_ == _default_operation_) {
    return NULL;
  } else {
    ::std::string* temp = operation_;
    operation_ = const_cast< ::std::string*>(_default_operation_);
    return temp;
  }
}
inline void EltwiseParameter::set_allocated_operation(::std::string* operation) {
  if (operation_ != _default_operation_) {
    delete operation_;
  }
  if (operation) {
    set_has_operation();
    operation_ = operation;
  } else {
    clear_has_operation();
    operation_ = const_cast< ::std::string*>(_default_operation_);
  }
}

// repeated float coeff = 2;
inline int EltwiseParameter::coeff_size() const {
  return coeff_.size();
}
inline void EltwiseParameter::clear_coeff() {
  coeff_.Clear();
}
inline float EltwiseParameter::coeff(int index) const {
  return coeff_.Get(index);
}
inline void EltwiseParameter::set_coeff(int index, float value) {
  coeff_.Set(index, value);
}
inline void EltwiseParameter::add_coeff(float value) {
  coeff_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
EltwiseParameter::coeff() const {
  return coeff_;
}
inline ::google::protobuf::RepeatedField< float >*
EltwiseParameter::mutable_coeff() {
  return &coeff_;
}

// optional bool stable_prod_grad = 3 [default = true];
inline bool EltwiseParameter::has_stable_prod_grad() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EltwiseParameter::set_has_stable_prod_grad() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EltwiseParameter::clear_has_stable_prod_grad() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EltwiseParameter::clear_stable_prod_grad() {
  stable_prod_grad_ = true;
  clear_has_stable_prod_grad();
}
inline bool EltwiseParameter::stable_prod_grad() const {
  return stable_prod_grad_;
}
inline void EltwiseParameter::set_stable_prod_grad(bool value) {
  set_has_stable_prod_grad();
  stable_prod_grad_ = value;
}

// repeated bool backward = 4;
inline int EltwiseParameter::backward_size() const {
  return backward_.size();
}
inline void EltwiseParameter::clear_backward() {
  backward_.Clear();
}
inline bool EltwiseParameter::backward(int index) const {
  return backward_.Get(index);
}
inline void EltwiseParameter::set_backward(int index, bool value) {
  backward_.Set(index, value);
}
inline void EltwiseParameter::add_backward(bool value) {
  backward_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
EltwiseParameter::backward() const {
  return backward_;
}
inline ::google::protobuf::RepeatedField< bool >*
EltwiseParameter::mutable_backward() {
  return &backward_;
}

// -------------------------------------------------------------------

// CRFParameter

// optional int32 max_iter = 1 [default = 1];
inline bool CRFParameter::has_max_iter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRFParameter::set_has_max_iter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRFParameter::clear_has_max_iter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRFParameter::clear_max_iter() {
  max_iter_ = 1;
  clear_has_max_iter();
}
inline ::google::protobuf::int32 CRFParameter::max_iter() const {
  return max_iter_;
}
inline void CRFParameter::set_max_iter(::google::protobuf::int32 value) {
  set_has_max_iter();
  max_iter_ = value;
}

// optional float radius = 2;
inline bool CRFParameter::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CRFParameter::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CRFParameter::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CRFParameter::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float CRFParameter::radius() const {
  return radius_;
}
inline void CRFParameter::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// optional float scale = 3 [default = 0.01];
inline bool CRFParameter::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CRFParameter::set_has_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CRFParameter::clear_has_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CRFParameter::clear_scale() {
  scale_ = 0.01f;
  clear_has_scale();
}
inline float CRFParameter::scale() const {
  return scale_;
}
inline void CRFParameter::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// optional float eps = 4 [default = 0.01];
inline bool CRFParameter::has_eps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CRFParameter::set_has_eps() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CRFParameter::clear_has_eps() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CRFParameter::clear_eps() {
  eps_ = 0.01f;
  clear_has_eps();
}
inline float CRFParameter::eps() const {
  return eps_;
}
inline void CRFParameter::set_eps(float value) {
  set_has_eps();
  eps_ = value;
}

// optional float alpha = 5 [default = 0.01];
inline bool CRFParameter::has_alpha() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CRFParameter::set_has_alpha() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CRFParameter::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CRFParameter::clear_alpha() {
  alpha_ = 0.01f;
  clear_has_alpha();
}
inline float CRFParameter::alpha() const {
  return alpha_;
}
inline void CRFParameter::set_alpha(float value) {
  set_has_alpha();
  alpha_ = value;
}

// -------------------------------------------------------------------

// ContextPoolingParameter

// optional uint32 context_h = 1 [default = 0];
inline bool ContextPoolingParameter::has_context_h() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContextPoolingParameter::set_has_context_h() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContextPoolingParameter::clear_has_context_h() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContextPoolingParameter::clear_context_h() {
  context_h_ = 0u;
  clear_has_context_h();
}
inline ::google::protobuf::uint32 ContextPoolingParameter::context_h() const {
  return context_h_;
}
inline void ContextPoolingParameter::set_context_h(::google::protobuf::uint32 value) {
  set_has_context_h();
  context_h_ = value;
}

// optional uint32 context_w = 2 [default = 0];
inline bool ContextPoolingParameter::has_context_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContextPoolingParameter::set_has_context_w() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContextPoolingParameter::clear_has_context_w() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContextPoolingParameter::clear_context_w() {
  context_w_ = 0u;
  clear_has_context_w();
}
inline ::google::protobuf::uint32 ContextPoolingParameter::context_w() const {
  return context_w_;
}
inline void ContextPoolingParameter::set_context_w(::google::protobuf::uint32 value) {
  set_has_context_w();
  context_w_ = value;
}

// optional string pool = 3;
inline bool ContextPoolingParameter::has_pool() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContextPoolingParameter::set_has_pool() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContextPoolingParameter::clear_has_pool() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContextPoolingParameter::clear_pool() {
  if (pool_ != &::google::protobuf::internal::kEmptyString) {
    pool_->clear();
  }
  clear_has_pool();
}
inline const ::std::string& ContextPoolingParameter::pool() const {
  return *pool_;
}
inline void ContextPoolingParameter::set_pool(const ::std::string& value) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void ContextPoolingParameter::set_pool(const char* value) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void ContextPoolingParameter::set_pool(const char* value, size_t size) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContextPoolingParameter::mutable_pool() {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  return pool_;
}
inline ::std::string* ContextPoolingParameter::release_pool() {
  clear_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pool_;
    pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContextPoolingParameter::set_allocated_pool(::std::string* pool) {
  if (pool_ != &::google::protobuf::internal::kEmptyString) {
    delete pool_;
  }
  if (pool) {
    set_has_pool();
    pool_ = pool;
  } else {
    clear_has_pool();
    pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mode = 4;
inline bool ContextPoolingParameter::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContextPoolingParameter::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContextPoolingParameter::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContextPoolingParameter::clear_mode() {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    mode_->clear();
  }
  clear_has_mode();
}
inline const ::std::string& ContextPoolingParameter::mode() const {
  return *mode_;
}
inline void ContextPoolingParameter::set_mode(const ::std::string& value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
}
inline void ContextPoolingParameter::set_mode(const char* value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
}
inline void ContextPoolingParameter::set_mode(const char* value, size_t size) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContextPoolingParameter::mutable_mode() {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  return mode_;
}
inline ::std::string* ContextPoolingParameter::release_mode() {
  clear_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mode_;
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContextPoolingParameter::set_allocated_mode(::std::string* mode) {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    delete mode_;
  }
  if (mode) {
    set_has_mode();
    mode_ = mode;
  } else {
    clear_has_mode();
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NormalizeParameter

// optional float scale_value = 1 [default = 1];
inline bool NormalizeParameter::has_scale_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NormalizeParameter::set_has_scale_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NormalizeParameter::clear_has_scale_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NormalizeParameter::clear_scale_value() {
  scale_value_ = 1;
  clear_has_scale_value();
}
inline float NormalizeParameter::scale_value() const {
  return scale_value_;
}
inline void NormalizeParameter::set_scale_value(float value) {
  set_has_scale_value();
  scale_value_ = value;
}

// optional float eps = 2 [default = 1e-10];
inline bool NormalizeParameter::has_eps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NormalizeParameter::set_has_eps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NormalizeParameter::clear_has_eps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NormalizeParameter::clear_eps() {
  eps_ = 1e-10f;
  clear_has_eps();
}
inline float NormalizeParameter::eps() const {
  return eps_;
}
inline void NormalizeParameter::set_eps(float value) {
  set_has_eps();
  eps_ = value;
}

// -------------------------------------------------------------------

// AccuracyParameter

// optional uint32 top_k = 1 [default = 1];
inline bool AccuracyParameter::has_top_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccuracyParameter::set_has_top_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccuracyParameter::clear_has_top_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccuracyParameter::clear_top_k() {
  top_k_ = 1u;
  clear_has_top_k();
}
inline ::google::protobuf::uint32 AccuracyParameter::top_k() const {
  return top_k_;
}
inline void AccuracyParameter::set_top_k(::google::protobuf::uint32 value) {
  set_has_top_k();
  top_k_ = value;
}

// optional int32 ignore_label = 2;
inline bool AccuracyParameter::has_ignore_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccuracyParameter::set_has_ignore_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccuracyParameter::clear_has_ignore_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccuracyParameter::clear_ignore_label() {
  ignore_label_ = 0;
  clear_has_ignore_label();
}
inline ::google::protobuf::int32 AccuracyParameter::ignore_label() const {
  return ignore_label_;
}
inline void AccuracyParameter::set_ignore_label(::google::protobuf::int32 value) {
  set_has_ignore_label();
  ignore_label_ = value;
}

// -------------------------------------------------------------------

// ShortcutParameter

// optional float scale = 1;
inline bool ShortcutParameter::has_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShortcutParameter::set_has_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShortcutParameter::clear_has_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShortcutParameter::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float ShortcutParameter::scale() const {
  return scale_;
}
inline void ShortcutParameter::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// optional float dropout_ratio = 2 [default = 0.5];
inline bool ShortcutParameter::has_dropout_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShortcutParameter::set_has_dropout_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShortcutParameter::clear_has_dropout_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShortcutParameter::clear_dropout_ratio() {
  dropout_ratio_ = 0.5f;
  clear_has_dropout_ratio();
}
inline float ShortcutParameter::dropout_ratio() const {
  return dropout_ratio_;
}
inline void ShortcutParameter::set_dropout_ratio(float value) {
  set_has_dropout_ratio();
  dropout_ratio_ = value;
}

// optional uint32 groups = 3 [default = 1];
inline bool ShortcutParameter::has_groups() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShortcutParameter::set_has_groups() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShortcutParameter::clear_has_groups() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShortcutParameter::clear_groups() {
  groups_ = 1u;
  clear_has_groups();
}
inline ::google::protobuf::uint32 ShortcutParameter::groups() const {
  return groups_;
}
inline void ShortcutParameter::set_groups(::google::protobuf::uint32 value) {
  set_has_groups();
  groups_ = value;
}

// -------------------------------------------------------------------

// BatchNormParameter

// optional string bn_state = 1 [default = "learned"];
inline bool BatchNormParameter::has_bn_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchNormParameter::set_has_bn_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchNormParameter::clear_has_bn_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchNormParameter::clear_bn_state() {
  if (bn_state_ != _default_bn_state_) {
    bn_state_->assign(*_default_bn_state_);
  }
  clear_has_bn_state();
}
inline const ::std::string& BatchNormParameter::bn_state() const {
  return *bn_state_;
}
inline void BatchNormParameter::set_bn_state(const ::std::string& value) {
  set_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    bn_state_ = new ::std::string;
  }
  bn_state_->assign(value);
}
inline void BatchNormParameter::set_bn_state(const char* value) {
  set_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    bn_state_ = new ::std::string;
  }
  bn_state_->assign(value);
}
inline void BatchNormParameter::set_bn_state(const char* value, size_t size) {
  set_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    bn_state_ = new ::std::string;
  }
  bn_state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BatchNormParameter::mutable_bn_state() {
  set_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    bn_state_ = new ::std::string(*_default_bn_state_);
  }
  return bn_state_;
}
inline ::std::string* BatchNormParameter::release_bn_state() {
  clear_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    return NULL;
  } else {
    ::std::string* temp = bn_state_;
    bn_state_ = const_cast< ::std::string*>(_default_bn_state_);
    return temp;
  }
}
inline void BatchNormParameter::set_allocated_bn_state(::std::string* bn_state) {
  if (bn_state_ != _default_bn_state_) {
    delete bn_state_;
  }
  if (bn_state) {
    set_has_bn_state();
    bn_state_ = bn_state;
  } else {
    clear_has_bn_state();
    bn_state_ = const_cast< ::std::string*>(_default_bn_state_);
  }
}

// -------------------------------------------------------------------

// InputBlob

// optional string name = 1;
inline bool InputBlob::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputBlob::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputBlob::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputBlob::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InputBlob::name() const {
  return *name_;
}
inline void InputBlob::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InputBlob::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InputBlob::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InputBlob::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* InputBlob::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InputBlob::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 num = 2;
inline bool InputBlob::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputBlob::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputBlob::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputBlob::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 InputBlob::num() const {
  return num_;
}
inline void InputBlob::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 channels = 3;
inline bool InputBlob::has_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputBlob::set_has_channels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputBlob::clear_has_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputBlob::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 InputBlob::channels() const {
  return channels_;
}
inline void InputBlob::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 4;
inline bool InputBlob::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputBlob::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InputBlob::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InputBlob::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 InputBlob::height() const {
  return height_;
}
inline void InputBlob::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 5;
inline bool InputBlob::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InputBlob::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InputBlob::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InputBlob::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 InputBlob::width() const {
  return width_;
}
inline void InputBlob::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// -------------------------------------------------------------------

// NetParameter

// optional string name = 1;
inline bool NetParameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetParameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetParameter::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NetParameter::name() const {
  return *name_;
}
inline void NetParameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NetParameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NetParameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetParameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NetParameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NetParameter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .caffe.LayerParameter layer = 100;
inline int NetParameter::layer_size() const {
  return layer_.size();
}
inline void NetParameter::clear_layer() {
  layer_.Clear();
}
inline const ::caffe::LayerParameter& NetParameter::layer(int index) const {
  return layer_.Get(index);
}
inline ::caffe::LayerParameter* NetParameter::mutable_layer(int index) {
  return layer_.Mutable(index);
}
inline ::caffe::LayerParameter* NetParameter::add_layer() {
  return layer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >&
NetParameter::layer() const {
  return layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >*
NetParameter::mutable_layer() {
  return &layer_;
}

// repeated string input = 3;
inline int NetParameter::input_size() const {
  return input_.size();
}
inline void NetParameter::clear_input() {
  input_.Clear();
}
inline const ::std::string& NetParameter::input(int index) const {
  return input_.Get(index);
}
inline ::std::string* NetParameter::mutable_input(int index) {
  return input_.Mutable(index);
}
inline void NetParameter::set_input(int index, const ::std::string& value) {
  input_.Mutable(index)->assign(value);
}
inline void NetParameter::set_input(int index, const char* value) {
  input_.Mutable(index)->assign(value);
}
inline void NetParameter::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetParameter::add_input() {
  return input_.Add();
}
inline void NetParameter::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
}
inline void NetParameter::add_input(const char* value) {
  input_.Add()->assign(value);
}
inline void NetParameter::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetParameter::input() const {
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetParameter::mutable_input() {
  return &input_;
}

// repeated .caffe.InputBlob input_blob = 5;
inline int NetParameter::input_blob_size() const {
  return input_blob_.size();
}
inline void NetParameter::clear_input_blob() {
  input_blob_.Clear();
}
inline const ::caffe::InputBlob& NetParameter::input_blob(int index) const {
  return input_blob_.Get(index);
}
inline ::caffe::InputBlob* NetParameter::mutable_input_blob(int index) {
  return input_blob_.Mutable(index);
}
inline ::caffe::InputBlob* NetParameter::add_input_blob() {
  return input_blob_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe::InputBlob >&
NetParameter::input_blob() const {
  return input_blob_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe::InputBlob >*
NetParameter::mutable_input_blob() {
  return &input_blob_;
}

// optional int32 num_flow = 6 [default = 0];
inline bool NetParameter::has_num_flow() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetParameter::set_has_num_flow() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetParameter::clear_has_num_flow() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetParameter::clear_num_flow() {
  num_flow_ = 0;
  clear_has_num_flow();
}
inline ::google::protobuf::int32 NetParameter::num_flow() const {
  return num_flow_;
}
inline void NetParameter::set_num_flow(::google::protobuf::int32 value) {
  set_has_num_flow();
  num_flow_ = value;
}

// -------------------------------------------------------------------

// NetOptimizer

// optional float base_lr = 1;
inline bool NetOptimizer::has_base_lr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetOptimizer::set_has_base_lr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetOptimizer::clear_has_base_lr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetOptimizer::clear_base_lr() {
  base_lr_ = 0;
  clear_has_base_lr();
}
inline float NetOptimizer::base_lr() const {
  return base_lr_;
}
inline void NetOptimizer::set_base_lr(float value) {
  set_has_base_lr();
  base_lr_ = value;
}

// optional string type = 2 [default = "SGD"];
inline bool NetOptimizer::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetOptimizer::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetOptimizer::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetOptimizer::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& NetOptimizer::type() const {
  return *type_;
}
inline void NetOptimizer::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void NetOptimizer::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void NetOptimizer::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetOptimizer::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  return type_;
}
inline ::std::string* NetOptimizer::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void NetOptimizer::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
}

// optional string lr_policy = 3;
inline bool NetOptimizer::has_lr_policy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetOptimizer::set_has_lr_policy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetOptimizer::clear_has_lr_policy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetOptimizer::clear_lr_policy() {
  if (lr_policy_ != &::google::protobuf::internal::kEmptyString) {
    lr_policy_->clear();
  }
  clear_has_lr_policy();
}
inline const ::std::string& NetOptimizer::lr_policy() const {
  return *lr_policy_;
}
inline void NetOptimizer::set_lr_policy(const ::std::string& value) {
  set_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    lr_policy_ = new ::std::string;
  }
  lr_policy_->assign(value);
}
inline void NetOptimizer::set_lr_policy(const char* value) {
  set_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    lr_policy_ = new ::std::string;
  }
  lr_policy_->assign(value);
}
inline void NetOptimizer::set_lr_policy(const char* value, size_t size) {
  set_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    lr_policy_ = new ::std::string;
  }
  lr_policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetOptimizer::mutable_lr_policy() {
  set_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    lr_policy_ = new ::std::string;
  }
  return lr_policy_;
}
inline ::std::string* NetOptimizer::release_lr_policy() {
  clear_has_lr_policy();
  if (lr_policy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lr_policy_;
    lr_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NetOptimizer::set_allocated_lr_policy(::std::string* lr_policy) {
  if (lr_policy_ != &::google::protobuf::internal::kEmptyString) {
    delete lr_policy_;
  }
  if (lr_policy) {
    set_has_lr_policy();
    lr_policy_ = lr_policy;
  } else {
    clear_has_lr_policy();
    lr_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float gamma = 4;
inline bool NetOptimizer::has_gamma() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetOptimizer::set_has_gamma() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetOptimizer::clear_has_gamma() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetOptimizer::clear_gamma() {
  gamma_ = 0;
  clear_has_gamma();
}
inline float NetOptimizer::gamma() const {
  return gamma_;
}
inline void NetOptimizer::set_gamma(float value) {
  set_has_gamma();
  gamma_ = value;
}

// optional float power = 5;
inline bool NetOptimizer::has_power() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetOptimizer::set_has_power() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetOptimizer::clear_has_power() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetOptimizer::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline float NetOptimizer::power() const {
  return power_;
}
inline void NetOptimizer::set_power(float value) {
  set_has_power();
  power_ = value;
}

// optional int32 stepsize = 6;
inline bool NetOptimizer::has_stepsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetOptimizer::set_has_stepsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetOptimizer::clear_has_stepsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetOptimizer::clear_stepsize() {
  stepsize_ = 0;
  clear_has_stepsize();
}
inline ::google::protobuf::int32 NetOptimizer::stepsize() const {
  return stepsize_;
}
inline void NetOptimizer::set_stepsize(::google::protobuf::int32 value) {
  set_has_stepsize();
  stepsize_ = value;
}

// repeated int32 stepvalue = 7;
inline int NetOptimizer::stepvalue_size() const {
  return stepvalue_.size();
}
inline void NetOptimizer::clear_stepvalue() {
  stepvalue_.Clear();
}
inline ::google::protobuf::int32 NetOptimizer::stepvalue(int index) const {
  return stepvalue_.Get(index);
}
inline void NetOptimizer::set_stepvalue(int index, ::google::protobuf::int32 value) {
  stepvalue_.Set(index, value);
}
inline void NetOptimizer::add_stepvalue(::google::protobuf::int32 value) {
  stepvalue_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NetOptimizer::stepvalue() const {
  return stepvalue_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NetOptimizer::mutable_stepvalue() {
  return &stepvalue_;
}

// optional float momentum = 8 [default = 0.9];
inline bool NetOptimizer::has_momentum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NetOptimizer::set_has_momentum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NetOptimizer::clear_has_momentum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NetOptimizer::clear_momentum() {
  momentum_ = 0.9f;
  clear_has_momentum();
}
inline float NetOptimizer::momentum() const {
  return momentum_;
}
inline void NetOptimizer::set_momentum(float value) {
  set_has_momentum();
  momentum_ = value;
}

// optional float weight_decay = 9;
inline bool NetOptimizer::has_weight_decay() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NetOptimizer::set_has_weight_decay() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NetOptimizer::clear_has_weight_decay() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NetOptimizer::clear_weight_decay() {
  weight_decay_ = 0;
  clear_has_weight_decay();
}
inline float NetOptimizer::weight_decay() const {
  return weight_decay_;
}
inline void NetOptimizer::set_weight_decay(float value) {
  set_has_weight_decay();
  weight_decay_ = value;
}

// optional int32 display = 11;
inline bool NetOptimizer::has_display() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NetOptimizer::set_has_display() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NetOptimizer::clear_has_display() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NetOptimizer::clear_display() {
  display_ = 0;
  clear_has_display();
}
inline ::google::protobuf::int32 NetOptimizer::display() const {
  return display_;
}
inline void NetOptimizer::set_display(::google::protobuf::int32 value) {
  set_has_display();
  display_ = value;
}

// optional int32 average_loss = 12 [default = 1];
inline bool NetOptimizer::has_average_loss() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NetOptimizer::set_has_average_loss() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NetOptimizer::clear_has_average_loss() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NetOptimizer::clear_average_loss() {
  average_loss_ = 1;
  clear_has_average_loss();
}
inline ::google::protobuf::int32 NetOptimizer::average_loss() const {
  return average_loss_;
}
inline void NetOptimizer::set_average_loss(::google::protobuf::int32 value) {
  set_has_average_loss();
  average_loss_ = value;
}

// optional float momentum2 = 13 [default = 0.999];
inline bool NetOptimizer::has_momentum2() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NetOptimizer::set_has_momentum2() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NetOptimizer::clear_has_momentum2() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NetOptimizer::clear_momentum2() {
  momentum2_ = 0.999f;
  clear_has_momentum2();
}
inline float NetOptimizer::momentum2() const {
  return momentum2_;
}
inline void NetOptimizer::set_momentum2(float value) {
  set_has_momentum2();
  momentum2_ = value;
}

// optional float delta = 14 [default = 1e-08];
inline bool NetOptimizer::has_delta() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NetOptimizer::set_has_delta() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NetOptimizer::clear_has_delta() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NetOptimizer::clear_delta() {
  delta_ = 1e-08f;
  clear_has_delta();
}
inline float NetOptimizer::delta() const {
  return delta_;
}
inline void NetOptimizer::set_delta(float value) {
  set_has_delta();
  delta_ = value;
}

// -------------------------------------------------------------------

// SolverState

// optional int32 iter = 1;
inline bool SolverState::has_iter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverState::set_has_iter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverState::clear_has_iter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverState::clear_iter() {
  iter_ = 0;
  clear_has_iter();
}
inline ::google::protobuf::int32 SolverState::iter() const {
  return iter_;
}
inline void SolverState::set_iter(::google::protobuf::int32 value) {
  set_has_iter();
  iter_ = value;
}

// optional string learned_net = 2;
inline bool SolverState::has_learned_net() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverState::set_has_learned_net() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverState::clear_has_learned_net() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverState::clear_learned_net() {
  if (learned_net_ != &::google::protobuf::internal::kEmptyString) {
    learned_net_->clear();
  }
  clear_has_learned_net();
}
inline const ::std::string& SolverState::learned_net() const {
  return *learned_net_;
}
inline void SolverState::set_learned_net(const ::std::string& value) {
  set_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    learned_net_ = new ::std::string;
  }
  learned_net_->assign(value);
}
inline void SolverState::set_learned_net(const char* value) {
  set_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    learned_net_ = new ::std::string;
  }
  learned_net_->assign(value);
}
inline void SolverState::set_learned_net(const char* value, size_t size) {
  set_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    learned_net_ = new ::std::string;
  }
  learned_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverState::mutable_learned_net() {
  set_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    learned_net_ = new ::std::string;
  }
  return learned_net_;
}
inline ::std::string* SolverState::release_learned_net() {
  clear_has_learned_net();
  if (learned_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = learned_net_;
    learned_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverState::set_allocated_learned_net(::std::string* learned_net) {
  if (learned_net_ != &::google::protobuf::internal::kEmptyString) {
    delete learned_net_;
  }
  if (learned_net) {
    set_has_learned_net();
    learned_net_ = learned_net;
  } else {
    clear_has_learned_net();
    learned_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe.NetState net_state = 3;
inline bool SolverState::has_net_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolverState::set_has_net_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolverState::clear_has_net_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolverState::clear_net_state() {
  if (net_state_ != NULL) net_state_->::caffe::NetState::Clear();
  clear_has_net_state();
}
inline const ::caffe::NetState& SolverState::net_state() const {
  return net_state_ != NULL ? *net_state_ : *default_instance_->net_state_;
}
inline ::caffe::NetState* SolverState::mutable_net_state() {
  set_has_net_state();
  if (net_state_ == NULL) net_state_ = new ::caffe::NetState;
  return net_state_;
}
inline ::caffe::NetState* SolverState::release_net_state() {
  clear_has_net_state();
  ::caffe::NetState* temp = net_state_;
  net_state_ = NULL;
  return temp;
}
inline void SolverState::set_allocated_net_state(::caffe::NetState* net_state) {
  delete net_state_;
  net_state_ = net_state;
  if (net_state) {
    set_has_net_state();
  } else {
    clear_has_net_state();
  }
}

// optional string d_state_file = 4;
inline bool SolverState::has_d_state_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolverState::set_has_d_state_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolverState::clear_has_d_state_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolverState::clear_d_state_file() {
  if (d_state_file_ != &::google::protobuf::internal::kEmptyString) {
    d_state_file_->clear();
  }
  clear_has_d_state_file();
}
inline const ::std::string& SolverState::d_state_file() const {
  return *d_state_file_;
}
inline void SolverState::set_d_state_file(const ::std::string& value) {
  set_has_d_state_file();
  if (d_state_file_ == &::google::protobuf::internal::kEmptyString) {
    d_state_file_ = new ::std::string;
  }
  d_state_file_->assign(value);
}
inline void SolverState::set_d_state_file(const char* value) {
  set_has_d_state_file();
  if (d_state_file_ == &::google::protobuf::internal::kEmptyString) {
    d_state_file_ = new ::std::string;
  }
  d_state_file_->assign(value);
}
inline void SolverState::set_d_state_file(const char* value, size_t size) {
  set_has_d_state_file();
  if (d_state_file_ == &::google::protobuf::internal::kEmptyString) {
    d_state_file_ = new ::std::string;
  }
  d_state_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverState::mutable_d_state_file() {
  set_has_d_state_file();
  if (d_state_file_ == &::google::protobuf::internal::kEmptyString) {
    d_state_file_ = new ::std::string;
  }
  return d_state_file_;
}
inline ::std::string* SolverState::release_d_state_file() {
  clear_has_d_state_file();
  if (d_state_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = d_state_file_;
    d_state_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverState::set_allocated_d_state_file(::std::string* d_state_file) {
  if (d_state_file_ != &::google::protobuf::internal::kEmptyString) {
    delete d_state_file_;
  }
  if (d_state_file) {
    set_has_d_state_file();
    d_state_file_ = d_state_file;
  } else {
    clear_has_d_state_file();
    d_state_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string g_state_file = 5;
inline bool SolverState::has_g_state_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolverState::set_has_g_state_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolverState::clear_has_g_state_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolverState::clear_g_state_file() {
  if (g_state_file_ != &::google::protobuf::internal::kEmptyString) {
    g_state_file_->clear();
  }
  clear_has_g_state_file();
}
inline const ::std::string& SolverState::g_state_file() const {
  return *g_state_file_;
}
inline void SolverState::set_g_state_file(const ::std::string& value) {
  set_has_g_state_file();
  if (g_state_file_ == &::google::protobuf::internal::kEmptyString) {
    g_state_file_ = new ::std::string;
  }
  g_state_file_->assign(value);
}
inline void SolverState::set_g_state_file(const char* value) {
  set_has_g_state_file();
  if (g_state_file_ == &::google::protobuf::internal::kEmptyString) {
    g_state_file_ = new ::std::string;
  }
  g_state_file_->assign(value);
}
inline void SolverState::set_g_state_file(const char* value, size_t size) {
  set_has_g_state_file();
  if (g_state_file_ == &::google::protobuf::internal::kEmptyString) {
    g_state_file_ = new ::std::string;
  }
  g_state_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverState::mutable_g_state_file() {
  set_has_g_state_file();
  if (g_state_file_ == &::google::protobuf::internal::kEmptyString) {
    g_state_file_ = new ::std::string;
  }
  return g_state_file_;
}
inline ::std::string* SolverState::release_g_state_file() {
  clear_has_g_state_file();
  if (g_state_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = g_state_file_;
    g_state_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverState::set_allocated_g_state_file(::std::string* g_state_file) {
  if (g_state_file_ != &::google::protobuf::internal::kEmptyString) {
    delete g_state_file_;
  }
  if (g_state_file) {
    set_has_g_state_file();
    g_state_file_ = g_state_file;
  } else {
    clear_has_g_state_file();
    g_state_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NetState

// repeated .caffe.LayerParameter layer = 1;
inline int NetState::layer_size() const {
  return layer_.size();
}
inline void NetState::clear_layer() {
  layer_.Clear();
}
inline const ::caffe::LayerParameter& NetState::layer(int index) const {
  return layer_.Get(index);
}
inline ::caffe::LayerParameter* NetState::mutable_layer(int index) {
  return layer_.Mutable(index);
}
inline ::caffe::LayerParameter* NetState::add_layer() {
  return layer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >&
NetState::layer() const {
  return layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe::LayerParameter >*
NetState::mutable_layer() {
  return &layer_;
}

// optional int32 adam_iter = 2;
inline bool NetState::has_adam_iter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetState::set_has_adam_iter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetState::clear_has_adam_iter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetState::clear_adam_iter() {
  adam_iter_ = 0;
  clear_has_adam_iter();
}
inline ::google::protobuf::int32 NetState::adam_iter() const {
  return adam_iter_;
}
inline void NetState::set_adam_iter(::google::protobuf::int32 value) {
  set_has_adam_iter();
  adam_iter_ = value;
}

// -------------------------------------------------------------------

// SolverParameter

// optional string net = 1;
inline bool SolverParameter::has_net() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverParameter::set_has_net() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverParameter::clear_has_net() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverParameter::clear_net() {
  if (net_ != &::google::protobuf::internal::kEmptyString) {
    net_->clear();
  }
  clear_has_net();
}
inline const ::std::string& SolverParameter::net() const {
  return *net_;
}
inline void SolverParameter::set_net(const ::std::string& value) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(value);
}
inline void SolverParameter::set_net(const char* value) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(value);
}
inline void SolverParameter::set_net(const char* value, size_t size) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_net() {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  return net_;
}
inline ::std::string* SolverParameter::release_net() {
  clear_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = net_;
    net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverParameter::set_allocated_net(::std::string* net) {
  if (net_ != &::google::protobuf::internal::kEmptyString) {
    delete net_;
  }
  if (net) {
    set_has_net();
    net_ = net;
  } else {
    clear_has_net();
    net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe.NetParameter net_param = 2;
inline bool SolverParameter::has_net_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverParameter::set_has_net_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverParameter::clear_has_net_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverParameter::clear_net_param() {
  if (net_param_ != NULL) net_param_->::caffe::NetParameter::Clear();
  clear_has_net_param();
}
inline const ::caffe::NetParameter& SolverParameter::net_param() const {
  return net_param_ != NULL ? *net_param_ : *default_instance_->net_param_;
}
inline ::caffe::NetParameter* SolverParameter::mutable_net_param() {
  set_has_net_param();
  if (net_param_ == NULL) net_param_ = new ::caffe::NetParameter;
  return net_param_;
}
inline ::caffe::NetParameter* SolverParameter::release_net_param() {
  clear_has_net_param();
  ::caffe::NetParameter* temp = net_param_;
  net_param_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_net_param(::caffe::NetParameter* net_param) {
  delete net_param_;
  net_param_ = net_param;
  if (net_param) {
    set_has_net_param();
  } else {
    clear_has_net_param();
  }
}

// optional .caffe.NetOptimizer net_opt = 3;
inline bool SolverParameter::has_net_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolverParameter::set_has_net_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolverParameter::clear_has_net_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolverParameter::clear_net_opt() {
  if (net_opt_ != NULL) net_opt_->::caffe::NetOptimizer::Clear();
  clear_has_net_opt();
}
inline const ::caffe::NetOptimizer& SolverParameter::net_opt() const {
  return net_opt_ != NULL ? *net_opt_ : *default_instance_->net_opt_;
}
inline ::caffe::NetOptimizer* SolverParameter::mutable_net_opt() {
  set_has_net_opt();
  if (net_opt_ == NULL) net_opt_ = new ::caffe::NetOptimizer;
  return net_opt_;
}
inline ::caffe::NetOptimizer* SolverParameter::release_net_opt() {
  clear_has_net_opt();
  ::caffe::NetOptimizer* temp = net_opt_;
  net_opt_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_net_opt(::caffe::NetOptimizer* net_opt) {
  delete net_opt_;
  net_opt_ = net_opt;
  if (net_opt) {
    set_has_net_opt();
  } else {
    clear_has_net_opt();
  }
}

// optional int32 max_iter = 4;
inline bool SolverParameter::has_max_iter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolverParameter::set_has_max_iter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolverParameter::clear_has_max_iter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolverParameter::clear_max_iter() {
  max_iter_ = 0;
  clear_has_max_iter();
}
inline ::google::protobuf::int32 SolverParameter::max_iter() const {
  return max_iter_;
}
inline void SolverParameter::set_max_iter(::google::protobuf::int32 value) {
  set_has_max_iter();
  max_iter_ = value;
}

// optional bool test_initialization = 5;
inline bool SolverParameter::has_test_initialization() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolverParameter::set_has_test_initialization() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolverParameter::clear_has_test_initialization() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolverParameter::clear_test_initialization() {
  test_initialization_ = false;
  clear_has_test_initialization();
}
inline bool SolverParameter::test_initialization() const {
  return test_initialization_;
}
inline void SolverParameter::set_test_initialization(bool value) {
  set_has_test_initialization();
  test_initialization_ = value;
}

// optional int32 test_interval = 6;
inline bool SolverParameter::has_test_interval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolverParameter::set_has_test_interval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolverParameter::clear_has_test_interval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolverParameter::clear_test_interval() {
  test_interval_ = 0;
  clear_has_test_interval();
}
inline ::google::protobuf::int32 SolverParameter::test_interval() const {
  return test_interval_;
}
inline void SolverParameter::set_test_interval(::google::protobuf::int32 value) {
  set_has_test_interval();
  test_interval_ = value;
}

// optional int32 test_iter = 7;
inline bool SolverParameter::has_test_iter() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolverParameter::set_has_test_iter() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolverParameter::clear_has_test_iter() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolverParameter::clear_test_iter() {
  test_iter_ = 0;
  clear_has_test_iter();
}
inline ::google::protobuf::int32 SolverParameter::test_iter() const {
  return test_iter_;
}
inline void SolverParameter::set_test_iter(::google::protobuf::int32 value) {
  set_has_test_iter();
  test_iter_ = value;
}

// optional string eval_type = 8 [default = "classification"];
inline bool SolverParameter::has_eval_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolverParameter::set_has_eval_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolverParameter::clear_has_eval_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolverParameter::clear_eval_type() {
  if (eval_type_ != _default_eval_type_) {
    eval_type_->assign(*_default_eval_type_);
  }
  clear_has_eval_type();
}
inline const ::std::string& SolverParameter::eval_type() const {
  return *eval_type_;
}
inline void SolverParameter::set_eval_type(const ::std::string& value) {
  set_has_eval_type();
  if (eval_type_ == _default_eval_type_) {
    eval_type_ = new ::std::string;
  }
  eval_type_->assign(value);
}
inline void SolverParameter::set_eval_type(const char* value) {
  set_has_eval_type();
  if (eval_type_ == _default_eval_type_) {
    eval_type_ = new ::std::string;
  }
  eval_type_->assign(value);
}
inline void SolverParameter::set_eval_type(const char* value, size_t size) {
  set_has_eval_type();
  if (eval_type_ == _default_eval_type_) {
    eval_type_ = new ::std::string;
  }
  eval_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_eval_type() {
  set_has_eval_type();
  if (eval_type_ == _default_eval_type_) {
    eval_type_ = new ::std::string(*_default_eval_type_);
  }
  return eval_type_;
}
inline ::std::string* SolverParameter::release_eval_type() {
  clear_has_eval_type();
  if (eval_type_ == _default_eval_type_) {
    return NULL;
  } else {
    ::std::string* temp = eval_type_;
    eval_type_ = const_cast< ::std::string*>(_default_eval_type_);
    return temp;
  }
}
inline void SolverParameter::set_allocated_eval_type(::std::string* eval_type) {
  if (eval_type_ != _default_eval_type_) {
    delete eval_type_;
  }
  if (eval_type) {
    set_has_eval_type();
    eval_type_ = eval_type;
  } else {
    clear_has_eval_type();
    eval_type_ = const_cast< ::std::string*>(_default_eval_type_);
  }
}

// optional bool accumulate_batch_norm = 9 [default = false];
inline bool SolverParameter::has_accumulate_batch_norm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolverParameter::set_has_accumulate_batch_norm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolverParameter::clear_has_accumulate_batch_norm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolverParameter::clear_accumulate_batch_norm() {
  accumulate_batch_norm_ = false;
  clear_has_accumulate_batch_norm();
}
inline bool SolverParameter::accumulate_batch_norm() const {
  return accumulate_batch_norm_;
}
inline void SolverParameter::set_accumulate_batch_norm(bool value) {
  set_has_accumulate_batch_norm();
  accumulate_batch_norm_ = value;
}

// optional uint32 accumulate_test_iter = 10;
inline bool SolverParameter::has_accumulate_test_iter() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SolverParameter::set_has_accumulate_test_iter() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SolverParameter::clear_has_accumulate_test_iter() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SolverParameter::clear_accumulate_test_iter() {
  accumulate_test_iter_ = 0u;
  clear_has_accumulate_test_iter();
}
inline ::google::protobuf::uint32 SolverParameter::accumulate_test_iter() const {
  return accumulate_test_iter_;
}
inline void SolverParameter::set_accumulate_test_iter(::google::protobuf::uint32 value) {
  set_has_accumulate_test_iter();
  accumulate_test_iter_ = value;
}

// optional uint32 accumulate_max_iter = 11;
inline bool SolverParameter::has_accumulate_max_iter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SolverParameter::set_has_accumulate_max_iter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SolverParameter::clear_has_accumulate_max_iter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SolverParameter::clear_accumulate_max_iter() {
  accumulate_max_iter_ = 0u;
  clear_has_accumulate_max_iter();
}
inline ::google::protobuf::uint32 SolverParameter::accumulate_max_iter() const {
  return accumulate_max_iter_;
}
inline void SolverParameter::set_accumulate_max_iter(::google::protobuf::uint32 value) {
  set_has_accumulate_max_iter();
  accumulate_max_iter_ = value;
}

// optional int32 iter_size = 12 [default = 1];
inline bool SolverParameter::has_iter_size() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SolverParameter::set_has_iter_size() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SolverParameter::clear_has_iter_size() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SolverParameter::clear_iter_size() {
  iter_size_ = 1;
  clear_has_iter_size();
}
inline ::google::protobuf::int32 SolverParameter::iter_size() const {
  return iter_size_;
}
inline void SolverParameter::set_iter_size(::google::protobuf::int32 value) {
  set_has_iter_size();
  iter_size_ = value;
}

// optional int32 snapshot = 13 [default = 0];
inline bool SolverParameter::has_snapshot() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SolverParameter::set_has_snapshot() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SolverParameter::clear_has_snapshot() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SolverParameter::clear_snapshot() {
  snapshot_ = 0;
  clear_has_snapshot();
}
inline ::google::protobuf::int32 SolverParameter::snapshot() const {
  return snapshot_;
}
inline void SolverParameter::set_snapshot(::google::protobuf::int32 value) {
  set_has_snapshot();
  snapshot_ = value;
}

// optional string snapshot_prefix = 14;
inline bool SolverParameter::has_snapshot_prefix() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SolverParameter::set_has_snapshot_prefix() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SolverParameter::clear_has_snapshot_prefix() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SolverParameter::clear_snapshot_prefix() {
  if (snapshot_prefix_ != &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_->clear();
  }
  clear_has_snapshot_prefix();
}
inline const ::std::string& SolverParameter::snapshot_prefix() const {
  return *snapshot_prefix_;
}
inline void SolverParameter::set_snapshot_prefix(const ::std::string& value) {
  set_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_ = new ::std::string;
  }
  snapshot_prefix_->assign(value);
}
inline void SolverParameter::set_snapshot_prefix(const char* value) {
  set_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_ = new ::std::string;
  }
  snapshot_prefix_->assign(value);
}
inline void SolverParameter::set_snapshot_prefix(const char* value, size_t size) {
  set_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_ = new ::std::string;
  }
  snapshot_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_snapshot_prefix() {
  set_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    snapshot_prefix_ = new ::std::string;
  }
  return snapshot_prefix_;
}
inline ::std::string* SolverParameter::release_snapshot_prefix() {
  clear_has_snapshot_prefix();
  if (snapshot_prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snapshot_prefix_;
    snapshot_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverParameter::set_allocated_snapshot_prefix(::std::string* snapshot_prefix) {
  if (snapshot_prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete snapshot_prefix_;
  }
  if (snapshot_prefix) {
    set_has_snapshot_prefix();
    snapshot_prefix_ = snapshot_prefix;
  } else {
    clear_has_snapshot_prefix();
    snapshot_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string solver_type = 15 [default = "CNN"];
inline bool SolverParameter::has_solver_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SolverParameter::set_has_solver_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SolverParameter::clear_has_solver_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SolverParameter::clear_solver_type() {
  if (solver_type_ != _default_solver_type_) {
    solver_type_->assign(*_default_solver_type_);
  }
  clear_has_solver_type();
}
inline const ::std::string& SolverParameter::solver_type() const {
  return *solver_type_;
}
inline void SolverParameter::set_solver_type(const ::std::string& value) {
  set_has_solver_type();
  if (solver_type_ == _default_solver_type_) {
    solver_type_ = new ::std::string;
  }
  solver_type_->assign(value);
}
inline void SolverParameter::set_solver_type(const char* value) {
  set_has_solver_type();
  if (solver_type_ == _default_solver_type_) {
    solver_type_ = new ::std::string;
  }
  solver_type_->assign(value);
}
inline void SolverParameter::set_solver_type(const char* value, size_t size) {
  set_has_solver_type();
  if (solver_type_ == _default_solver_type_) {
    solver_type_ = new ::std::string;
  }
  solver_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_solver_type() {
  set_has_solver_type();
  if (solver_type_ == _default_solver_type_) {
    solver_type_ = new ::std::string(*_default_solver_type_);
  }
  return solver_type_;
}
inline ::std::string* SolverParameter::release_solver_type() {
  clear_has_solver_type();
  if (solver_type_ == _default_solver_type_) {
    return NULL;
  } else {
    ::std::string* temp = solver_type_;
    solver_type_ = const_cast< ::std::string*>(_default_solver_type_);
    return temp;
  }
}
inline void SolverParameter::set_allocated_solver_type(::std::string* solver_type) {
  if (solver_type_ != _default_solver_type_) {
    delete solver_type_;
  }
  if (solver_type) {
    set_has_solver_type();
    solver_type_ = solver_type;
  } else {
    clear_has_solver_type();
    solver_type_ = const_cast< ::std::string*>(_default_solver_type_);
  }
}

// optional int32 display = 16;
inline bool SolverParameter::has_display() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SolverParameter::set_has_display() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SolverParameter::clear_has_display() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SolverParameter::clear_display() {
  display_ = 0;
  clear_has_display();
}
inline ::google::protobuf::int32 SolverParameter::display() const {
  return display_;
}
inline void SolverParameter::set_display(::google::protobuf::int32 value) {
  set_has_display();
  display_ = value;
}

// optional string bn_state = 18 [default = "learned"];
inline bool SolverParameter::has_bn_state() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SolverParameter::set_has_bn_state() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SolverParameter::clear_has_bn_state() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SolverParameter::clear_bn_state() {
  if (bn_state_ != _default_bn_state_) {
    bn_state_->assign(*_default_bn_state_);
  }
  clear_has_bn_state();
}
inline const ::std::string& SolverParameter::bn_state() const {
  return *bn_state_;
}
inline void SolverParameter::set_bn_state(const ::std::string& value) {
  set_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    bn_state_ = new ::std::string;
  }
  bn_state_->assign(value);
}
inline void SolverParameter::set_bn_state(const char* value) {
  set_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    bn_state_ = new ::std::string;
  }
  bn_state_->assign(value);
}
inline void SolverParameter::set_bn_state(const char* value, size_t size) {
  set_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    bn_state_ = new ::std::string;
  }
  bn_state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_bn_state() {
  set_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    bn_state_ = new ::std::string(*_default_bn_state_);
  }
  return bn_state_;
}
inline ::std::string* SolverParameter::release_bn_state() {
  clear_has_bn_state();
  if (bn_state_ == _default_bn_state_) {
    return NULL;
  } else {
    ::std::string* temp = bn_state_;
    bn_state_ = const_cast< ::std::string*>(_default_bn_state_);
    return temp;
  }
}
inline void SolverParameter::set_allocated_bn_state(::std::string* bn_state) {
  if (bn_state_ != _default_bn_state_) {
    delete bn_state_;
  }
  if (bn_state) {
    set_has_bn_state();
    bn_state_ = bn_state;
  } else {
    clear_has_bn_state();
    bn_state_ = const_cast< ::std::string*>(_default_bn_state_);
  }
}

// optional string drop_state = 19 [default = "rand"];
inline bool SolverParameter::has_drop_state() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SolverParameter::set_has_drop_state() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SolverParameter::clear_has_drop_state() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SolverParameter::clear_drop_state() {
  if (drop_state_ != _default_drop_state_) {
    drop_state_->assign(*_default_drop_state_);
  }
  clear_has_drop_state();
}
inline const ::std::string& SolverParameter::drop_state() const {
  return *drop_state_;
}
inline void SolverParameter::set_drop_state(const ::std::string& value) {
  set_has_drop_state();
  if (drop_state_ == _default_drop_state_) {
    drop_state_ = new ::std::string;
  }
  drop_state_->assign(value);
}
inline void SolverParameter::set_drop_state(const char* value) {
  set_has_drop_state();
  if (drop_state_ == _default_drop_state_) {
    drop_state_ = new ::std::string;
  }
  drop_state_->assign(value);
}
inline void SolverParameter::set_drop_state(const char* value, size_t size) {
  set_has_drop_state();
  if (drop_state_ == _default_drop_state_) {
    drop_state_ = new ::std::string;
  }
  drop_state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_drop_state() {
  set_has_drop_state();
  if (drop_state_ == _default_drop_state_) {
    drop_state_ = new ::std::string(*_default_drop_state_);
  }
  return drop_state_;
}
inline ::std::string* SolverParameter::release_drop_state() {
  clear_has_drop_state();
  if (drop_state_ == _default_drop_state_) {
    return NULL;
  } else {
    ::std::string* temp = drop_state_;
    drop_state_ = const_cast< ::std::string*>(_default_drop_state_);
    return temp;
  }
}
inline void SolverParameter::set_allocated_drop_state(::std::string* drop_state) {
  if (drop_state_ != _default_drop_state_) {
    delete drop_state_;
  }
  if (drop_state) {
    set_has_drop_state();
    drop_state_ = drop_state;
  } else {
    clear_has_drop_state();
    drop_state_ = const_cast< ::std::string*>(_default_drop_state_);
  }
}

// optional bool second_pass = 20 [default = false];
inline bool SolverParameter::has_second_pass() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SolverParameter::set_has_second_pass() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SolverParameter::clear_has_second_pass() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SolverParameter::clear_second_pass() {
  second_pass_ = false;
  clear_has_second_pass();
}
inline bool SolverParameter::second_pass() const {
  return second_pass_;
}
inline void SolverParameter::set_second_pass(bool value) {
  set_has_second_pass();
  second_pass_ = value;
}

// optional string test_net = 21;
inline bool SolverParameter::has_test_net() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SolverParameter::set_has_test_net() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SolverParameter::clear_has_test_net() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SolverParameter::clear_test_net() {
  if (test_net_ != &::google::protobuf::internal::kEmptyString) {
    test_net_->clear();
  }
  clear_has_test_net();
}
inline const ::std::string& SolverParameter::test_net() const {
  return *test_net_;
}
inline void SolverParameter::set_test_net(const ::std::string& value) {
  set_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    test_net_ = new ::std::string;
  }
  test_net_->assign(value);
}
inline void SolverParameter::set_test_net(const char* value) {
  set_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    test_net_ = new ::std::string;
  }
  test_net_->assign(value);
}
inline void SolverParameter::set_test_net(const char* value, size_t size) {
  set_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    test_net_ = new ::std::string;
  }
  test_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_test_net() {
  set_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    test_net_ = new ::std::string;
  }
  return test_net_;
}
inline ::std::string* SolverParameter::release_test_net() {
  clear_has_test_net();
  if (test_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = test_net_;
    test_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverParameter::set_allocated_test_net(::std::string* test_net) {
  if (test_net_ != &::google::protobuf::internal::kEmptyString) {
    delete test_net_;
  }
  if (test_net) {
    set_has_test_net();
    test_net_ = test_net;
  } else {
    clear_has_test_net();
    test_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe.NetOptimizer g_net_opt = 100;
inline bool SolverParameter::has_g_net_opt() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SolverParameter::set_has_g_net_opt() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SolverParameter::clear_has_g_net_opt() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SolverParameter::clear_g_net_opt() {
  if (g_net_opt_ != NULL) g_net_opt_->::caffe::NetOptimizer::Clear();
  clear_has_g_net_opt();
}
inline const ::caffe::NetOptimizer& SolverParameter::g_net_opt() const {
  return g_net_opt_ != NULL ? *g_net_opt_ : *default_instance_->g_net_opt_;
}
inline ::caffe::NetOptimizer* SolverParameter::mutable_g_net_opt() {
  set_has_g_net_opt();
  if (g_net_opt_ == NULL) g_net_opt_ = new ::caffe::NetOptimizer;
  return g_net_opt_;
}
inline ::caffe::NetOptimizer* SolverParameter::release_g_net_opt() {
  clear_has_g_net_opt();
  ::caffe::NetOptimizer* temp = g_net_opt_;
  g_net_opt_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_g_net_opt(::caffe::NetOptimizer* g_net_opt) {
  delete g_net_opt_;
  g_net_opt_ = g_net_opt;
  if (g_net_opt) {
    set_has_g_net_opt();
  } else {
    clear_has_g_net_opt();
  }
}

// optional .caffe.NetOptimizer d_net_opt = 101;
inline bool SolverParameter::has_d_net_opt() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SolverParameter::set_has_d_net_opt() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SolverParameter::clear_has_d_net_opt() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SolverParameter::clear_d_net_opt() {
  if (d_net_opt_ != NULL) d_net_opt_->::caffe::NetOptimizer::Clear();
  clear_has_d_net_opt();
}
inline const ::caffe::NetOptimizer& SolverParameter::d_net_opt() const {
  return d_net_opt_ != NULL ? *d_net_opt_ : *default_instance_->d_net_opt_;
}
inline ::caffe::NetOptimizer* SolverParameter::mutable_d_net_opt() {
  set_has_d_net_opt();
  if (d_net_opt_ == NULL) d_net_opt_ = new ::caffe::NetOptimizer;
  return d_net_opt_;
}
inline ::caffe::NetOptimizer* SolverParameter::release_d_net_opt() {
  clear_has_d_net_opt();
  ::caffe::NetOptimizer* temp = d_net_opt_;
  d_net_opt_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_d_net_opt(::caffe::NetOptimizer* d_net_opt) {
  delete d_net_opt_;
  d_net_opt_ = d_net_opt;
  if (d_net_opt) {
    set_has_d_net_opt();
  } else {
    clear_has_d_net_opt();
  }
}

// optional string g_net = 102;
inline bool SolverParameter::has_g_net() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SolverParameter::set_has_g_net() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SolverParameter::clear_has_g_net() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SolverParameter::clear_g_net() {
  if (g_net_ != &::google::protobuf::internal::kEmptyString) {
    g_net_->clear();
  }
  clear_has_g_net();
}
inline const ::std::string& SolverParameter::g_net() const {
  return *g_net_;
}
inline void SolverParameter::set_g_net(const ::std::string& value) {
  set_has_g_net();
  if (g_net_ == &::google::protobuf::internal::kEmptyString) {
    g_net_ = new ::std::string;
  }
  g_net_->assign(value);
}
inline void SolverParameter::set_g_net(const char* value) {
  set_has_g_net();
  if (g_net_ == &::google::protobuf::internal::kEmptyString) {
    g_net_ = new ::std::string;
  }
  g_net_->assign(value);
}
inline void SolverParameter::set_g_net(const char* value, size_t size) {
  set_has_g_net();
  if (g_net_ == &::google::protobuf::internal::kEmptyString) {
    g_net_ = new ::std::string;
  }
  g_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_g_net() {
  set_has_g_net();
  if (g_net_ == &::google::protobuf::internal::kEmptyString) {
    g_net_ = new ::std::string;
  }
  return g_net_;
}
inline ::std::string* SolverParameter::release_g_net() {
  clear_has_g_net();
  if (g_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = g_net_;
    g_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverParameter::set_allocated_g_net(::std::string* g_net) {
  if (g_net_ != &::google::protobuf::internal::kEmptyString) {
    delete g_net_;
  }
  if (g_net) {
    set_has_g_net();
    g_net_ = g_net;
  } else {
    clear_has_g_net();
    g_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe.NetParameter g_net_param = 103;
inline bool SolverParameter::has_g_net_param() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SolverParameter::set_has_g_net_param() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SolverParameter::clear_has_g_net_param() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SolverParameter::clear_g_net_param() {
  if (g_net_param_ != NULL) g_net_param_->::caffe::NetParameter::Clear();
  clear_has_g_net_param();
}
inline const ::caffe::NetParameter& SolverParameter::g_net_param() const {
  return g_net_param_ != NULL ? *g_net_param_ : *default_instance_->g_net_param_;
}
inline ::caffe::NetParameter* SolverParameter::mutable_g_net_param() {
  set_has_g_net_param();
  if (g_net_param_ == NULL) g_net_param_ = new ::caffe::NetParameter;
  return g_net_param_;
}
inline ::caffe::NetParameter* SolverParameter::release_g_net_param() {
  clear_has_g_net_param();
  ::caffe::NetParameter* temp = g_net_param_;
  g_net_param_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_g_net_param(::caffe::NetParameter* g_net_param) {
  delete g_net_param_;
  g_net_param_ = g_net_param;
  if (g_net_param) {
    set_has_g_net_param();
  } else {
    clear_has_g_net_param();
  }
}

// optional string d_net = 106;
inline bool SolverParameter::has_d_net() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SolverParameter::set_has_d_net() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SolverParameter::clear_has_d_net() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SolverParameter::clear_d_net() {
  if (d_net_ != &::google::protobuf::internal::kEmptyString) {
    d_net_->clear();
  }
  clear_has_d_net();
}
inline const ::std::string& SolverParameter::d_net() const {
  return *d_net_;
}
inline void SolverParameter::set_d_net(const ::std::string& value) {
  set_has_d_net();
  if (d_net_ == &::google::protobuf::internal::kEmptyString) {
    d_net_ = new ::std::string;
  }
  d_net_->assign(value);
}
inline void SolverParameter::set_d_net(const char* value) {
  set_has_d_net();
  if (d_net_ == &::google::protobuf::internal::kEmptyString) {
    d_net_ = new ::std::string;
  }
  d_net_->assign(value);
}
inline void SolverParameter::set_d_net(const char* value, size_t size) {
  set_has_d_net();
  if (d_net_ == &::google::protobuf::internal::kEmptyString) {
    d_net_ = new ::std::string;
  }
  d_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_d_net() {
  set_has_d_net();
  if (d_net_ == &::google::protobuf::internal::kEmptyString) {
    d_net_ = new ::std::string;
  }
  return d_net_;
}
inline ::std::string* SolverParameter::release_d_net() {
  clear_has_d_net();
  if (d_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = d_net_;
    d_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverParameter::set_allocated_d_net(::std::string* d_net) {
  if (d_net_ != &::google::protobuf::internal::kEmptyString) {
    delete d_net_;
  }
  if (d_net) {
    set_has_d_net();
    d_net_ = d_net;
  } else {
    clear_has_d_net();
    d_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe.NetParameter d_net_param = 107;
inline bool SolverParameter::has_d_net_param() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SolverParameter::set_has_d_net_param() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SolverParameter::clear_has_d_net_param() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SolverParameter::clear_d_net_param() {
  if (d_net_param_ != NULL) d_net_param_->::caffe::NetParameter::Clear();
  clear_has_d_net_param();
}
inline const ::caffe::NetParameter& SolverParameter::d_net_param() const {
  return d_net_param_ != NULL ? *d_net_param_ : *default_instance_->d_net_param_;
}
inline ::caffe::NetParameter* SolverParameter::mutable_d_net_param() {
  set_has_d_net_param();
  if (d_net_param_ == NULL) d_net_param_ = new ::caffe::NetParameter;
  return d_net_param_;
}
inline ::caffe::NetParameter* SolverParameter::release_d_net_param() {
  clear_has_d_net_param();
  ::caffe::NetParameter* temp = d_net_param_;
  d_net_param_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_d_net_param(::caffe::NetParameter* d_net_param) {
  delete d_net_param_;
  d_net_param_ = d_net_param;
  if (d_net_param) {
    set_has_d_net_param();
  } else {
    clear_has_d_net_param();
  }
}

// optional string d_interp_net = 110;
inline bool SolverParameter::has_d_interp_net() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SolverParameter::set_has_d_interp_net() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SolverParameter::clear_has_d_interp_net() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SolverParameter::clear_d_interp_net() {
  if (d_interp_net_ != &::google::protobuf::internal::kEmptyString) {
    d_interp_net_->clear();
  }
  clear_has_d_interp_net();
}
inline const ::std::string& SolverParameter::d_interp_net() const {
  return *d_interp_net_;
}
inline void SolverParameter::set_d_interp_net(const ::std::string& value) {
  set_has_d_interp_net();
  if (d_interp_net_ == &::google::protobuf::internal::kEmptyString) {
    d_interp_net_ = new ::std::string;
  }
  d_interp_net_->assign(value);
}
inline void SolverParameter::set_d_interp_net(const char* value) {
  set_has_d_interp_net();
  if (d_interp_net_ == &::google::protobuf::internal::kEmptyString) {
    d_interp_net_ = new ::std::string;
  }
  d_interp_net_->assign(value);
}
inline void SolverParameter::set_d_interp_net(const char* value, size_t size) {
  set_has_d_interp_net();
  if (d_interp_net_ == &::google::protobuf::internal::kEmptyString) {
    d_interp_net_ = new ::std::string;
  }
  d_interp_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_d_interp_net() {
  set_has_d_interp_net();
  if (d_interp_net_ == &::google::protobuf::internal::kEmptyString) {
    d_interp_net_ = new ::std::string;
  }
  return d_interp_net_;
}
inline ::std::string* SolverParameter::release_d_interp_net() {
  clear_has_d_interp_net();
  if (d_interp_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = d_interp_net_;
    d_interp_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverParameter::set_allocated_d_interp_net(::std::string* d_interp_net) {
  if (d_interp_net_ != &::google::protobuf::internal::kEmptyString) {
    delete d_interp_net_;
  }
  if (d_interp_net) {
    set_has_d_interp_net();
    d_interp_net_ = d_interp_net;
  } else {
    clear_has_d_interp_net();
    d_interp_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string d_aux_net = 111;
inline bool SolverParameter::has_d_aux_net() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SolverParameter::set_has_d_aux_net() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SolverParameter::clear_has_d_aux_net() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SolverParameter::clear_d_aux_net() {
  if (d_aux_net_ != &::google::protobuf::internal::kEmptyString) {
    d_aux_net_->clear();
  }
  clear_has_d_aux_net();
}
inline const ::std::string& SolverParameter::d_aux_net() const {
  return *d_aux_net_;
}
inline void SolverParameter::set_d_aux_net(const ::std::string& value) {
  set_has_d_aux_net();
  if (d_aux_net_ == &::google::protobuf::internal::kEmptyString) {
    d_aux_net_ = new ::std::string;
  }
  d_aux_net_->assign(value);
}
inline void SolverParameter::set_d_aux_net(const char* value) {
  set_has_d_aux_net();
  if (d_aux_net_ == &::google::protobuf::internal::kEmptyString) {
    d_aux_net_ = new ::std::string;
  }
  d_aux_net_->assign(value);
}
inline void SolverParameter::set_d_aux_net(const char* value, size_t size) {
  set_has_d_aux_net();
  if (d_aux_net_ == &::google::protobuf::internal::kEmptyString) {
    d_aux_net_ = new ::std::string;
  }
  d_aux_net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SolverParameter::mutable_d_aux_net() {
  set_has_d_aux_net();
  if (d_aux_net_ == &::google::protobuf::internal::kEmptyString) {
    d_aux_net_ = new ::std::string;
  }
  return d_aux_net_;
}
inline ::std::string* SolverParameter::release_d_aux_net() {
  clear_has_d_aux_net();
  if (d_aux_net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = d_aux_net_;
    d_aux_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SolverParameter::set_allocated_d_aux_net(::std::string* d_aux_net) {
  if (d_aux_net_ != &::google::protobuf::internal::kEmptyString) {
    delete d_aux_net_;
  }
  if (d_aux_net) {
    set_has_d_aux_net();
    d_aux_net_ = d_aux_net;
  } else {
    clear_has_d_aux_net();
    d_aux_net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .caffe.NetParameter d_interp_param = 112;
inline bool SolverParameter::has_d_interp_param() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SolverParameter::set_has_d_interp_param() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SolverParameter::clear_has_d_interp_param() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SolverParameter::clear_d_interp_param() {
  if (d_interp_param_ != NULL) d_interp_param_->::caffe::NetParameter::Clear();
  clear_has_d_interp_param();
}
inline const ::caffe::NetParameter& SolverParameter::d_interp_param() const {
  return d_interp_param_ != NULL ? *d_interp_param_ : *default_instance_->d_interp_param_;
}
inline ::caffe::NetParameter* SolverParameter::mutable_d_interp_param() {
  set_has_d_interp_param();
  if (d_interp_param_ == NULL) d_interp_param_ = new ::caffe::NetParameter;
  return d_interp_param_;
}
inline ::caffe::NetParameter* SolverParameter::release_d_interp_param() {
  clear_has_d_interp_param();
  ::caffe::NetParameter* temp = d_interp_param_;
  d_interp_param_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_d_interp_param(::caffe::NetParameter* d_interp_param) {
  delete d_interp_param_;
  d_interp_param_ = d_interp_param;
  if (d_interp_param) {
    set_has_d_interp_param();
  } else {
    clear_has_d_interp_param();
  }
}

// optional .caffe.NetParameter d_aux_param = 113;
inline bool SolverParameter::has_d_aux_param() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SolverParameter::set_has_d_aux_param() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SolverParameter::clear_has_d_aux_param() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SolverParameter::clear_d_aux_param() {
  if (d_aux_param_ != NULL) d_aux_param_->::caffe::NetParameter::Clear();
  clear_has_d_aux_param();
}
inline const ::caffe::NetParameter& SolverParameter::d_aux_param() const {
  return d_aux_param_ != NULL ? *d_aux_param_ : *default_instance_->d_aux_param_;
}
inline ::caffe::NetParameter* SolverParameter::mutable_d_aux_param() {
  set_has_d_aux_param();
  if (d_aux_param_ == NULL) d_aux_param_ = new ::caffe::NetParameter;
  return d_aux_param_;
}
inline ::caffe::NetParameter* SolverParameter::release_d_aux_param() {
  clear_has_d_aux_param();
  ::caffe::NetParameter* temp = d_aux_param_;
  d_aux_param_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_d_aux_param(::caffe::NetParameter* d_aux_param) {
  delete d_aux_param_;
  d_aux_param_ = d_aux_param;
  if (d_aux_param) {
    set_has_d_aux_param();
  } else {
    clear_has_d_aux_param();
  }
}

// -------------------------------------------------------------------

// PoolingParameter

// optional string pool = 1 [default = "ave"];
inline bool PoolingParameter::has_pool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoolingParameter::set_has_pool() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoolingParameter::clear_has_pool() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoolingParameter::clear_pool() {
  if (pool_ != _default_pool_) {
    pool_->assign(*_default_pool_);
  }
  clear_has_pool();
}
inline const ::std::string& PoolingParameter::pool() const {
  return *pool_;
}
inline void PoolingParameter::set_pool(const ::std::string& value) {
  set_has_pool();
  if (pool_ == _default_pool_) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void PoolingParameter::set_pool(const char* value) {
  set_has_pool();
  if (pool_ == _default_pool_) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void PoolingParameter::set_pool(const char* value, size_t size) {
  set_has_pool();
  if (pool_ == _default_pool_) {
    pool_ = new ::std::string;
  }
  pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PoolingParameter::mutable_pool() {
  set_has_pool();
  if (pool_ == _default_pool_) {
    pool_ = new ::std::string(*_default_pool_);
  }
  return pool_;
}
inline ::std::string* PoolingParameter::release_pool() {
  clear_has_pool();
  if (pool_ == _default_pool_) {
    return NULL;
  } else {
    ::std::string* temp = pool_;
    pool_ = const_cast< ::std::string*>(_default_pool_);
    return temp;
  }
}
inline void PoolingParameter::set_allocated_pool(::std::string* pool) {
  if (pool_ != _default_pool_) {
    delete pool_;
  }
  if (pool) {
    set_has_pool();
    pool_ = pool;
  } else {
    clear_has_pool();
    pool_ = const_cast< ::std::string*>(_default_pool_);
  }
}

// optional uint32 pad = 2 [default = 0];
inline bool PoolingParameter::has_pad() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoolingParameter::set_has_pad() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoolingParameter::clear_has_pad() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoolingParameter::clear_pad() {
  pad_ = 0u;
  clear_has_pad();
}
inline ::google::protobuf::uint32 PoolingParameter::pad() const {
  return pad_;
}
inline void PoolingParameter::set_pad(::google::protobuf::uint32 value) {
  set_has_pad();
  pad_ = value;
}

// optional uint32 kernel_size = 3;
inline bool PoolingParameter::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoolingParameter::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoolingParameter::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoolingParameter::clear_kernel_size() {
  kernel_size_ = 0u;
  clear_has_kernel_size();
}
inline ::google::protobuf::uint32 PoolingParameter::kernel_size() const {
  return kernel_size_;
}
inline void PoolingParameter::set_kernel_size(::google::protobuf::uint32 value) {
  set_has_kernel_size();
  kernel_size_ = value;
}

// optional uint32 stride = 4 [default = 1];
inline bool PoolingParameter::has_stride() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PoolingParameter::set_has_stride() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PoolingParameter::clear_has_stride() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PoolingParameter::clear_stride() {
  stride_ = 1u;
  clear_has_stride();
}
inline ::google::protobuf::uint32 PoolingParameter::stride() const {
  return stride_;
}
inline void PoolingParameter::set_stride(::google::protobuf::uint32 value) {
  set_has_stride();
  stride_ = value;
}

// optional bool global_pool = 5 [default = false];
inline bool PoolingParameter::has_global_pool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PoolingParameter::set_has_global_pool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PoolingParameter::clear_has_global_pool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PoolingParameter::clear_global_pool() {
  global_pool_ = false;
  clear_has_global_pool();
}
inline bool PoolingParameter::global_pool() const {
  return global_pool_;
}
inline void PoolingParameter::set_global_pool(bool value) {
  set_has_global_pool();
  global_pool_ = value;
}

// -------------------------------------------------------------------

// LossParameter

// optional int32 ignore_label = 1;
inline bool LossParameter::has_ignore_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LossParameter::set_has_ignore_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LossParameter::clear_has_ignore_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LossParameter::clear_ignore_label() {
  ignore_label_ = 0;
  clear_has_ignore_label();
}
inline ::google::protobuf::int32 LossParameter::ignore_label() const {
  return ignore_label_;
}
inline void LossParameter::set_ignore_label(::google::protobuf::int32 value) {
  set_has_ignore_label();
  ignore_label_ = value;
}

// optional float keep_portion = 2 [default = 0.5];
inline bool LossParameter::has_keep_portion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LossParameter::set_has_keep_portion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LossParameter::clear_has_keep_portion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LossParameter::clear_keep_portion() {
  keep_portion_ = 0.5f;
  clear_has_keep_portion();
}
inline float LossParameter::keep_portion() const {
  return keep_portion_;
}
inline void LossParameter::set_keep_portion(float value) {
  set_has_keep_portion();
  keep_portion_ = value;
}

// optional bool single_term = 3 [default = false];
inline bool LossParameter::has_single_term() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LossParameter::set_has_single_term() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LossParameter::clear_has_single_term() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LossParameter::clear_single_term() {
  single_term_ = false;
  clear_has_single_term();
}
inline bool LossParameter::single_term() const {
  return single_term_;
}
inline void LossParameter::set_single_term(bool value) {
  set_has_single_term();
  single_term_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_src_2fcaffe_2fproto_2fcaffe_2eproto__INCLUDED
