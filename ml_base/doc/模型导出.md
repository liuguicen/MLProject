
 注意导出模型的时候对代码会有更多限制，自然的，因为导出模型运行环境一般会偏向于静态固定式的语言环境，所以相对动态python会有限制
 #pytorch导出
 ## 语法要求，注意事项：
 1、返回值类型必须一致，
 2、参数不能自动转型
 3、不能使用torch.Tensor(),要用torch.tensor()
 4、函数的默认参数如果不是tensor的话，需要指定类型
 5、list中元素默认为tensor，如果不是，也要指定类型 
 6、不支持一般的字典以及初始化语法，支持orderdict
 7.不支持continue
 8、不支持try-except
 - 很多函数jit不支持
 .type(torch.uint8),to(, 这里加了dtype不支持)
 更多的详见官方文档
 
## 步骤
 1、写好模型代码，不要训练，首先确认能否导出，有很多语法、组件，比如上面那些，是不支持导出的
 2、最简单的导出语法
 
```
    scripted_module = torch.jit.script(module)
    torch.jit.save(scripted_module, path)
```
## Android使用pytorch
3、基于Pytorch模型的树状结构，是支持导出模型的一个子模块或者说子模型的，不得不说设计者强大的背景知识和规划能力！
4、Android里面的使用方法：参考官网提供的demo  https://github.com/pytorch/android-demo-app
大致是：
-4.1 使用在线lib或者离线lib  
    implementation 'org.pytorch:pytorch_android:1.8.0'   
    implementation 'org.pytorch:pytorch_android_torchvision:1.8.0'   
-4.2 导入模型 Module.load(path)
-4.3  输入数据转化为tensor  
    final Tensor contentTensor = TensorImageUtils.bitmapToFloat32Tensor(contentBm,TensorImageUtils.TORCHVISION_NORM_MEAN_RGB, TensorImageUtils.TORCHVISION_NORM_STD_RGB);   
-4.4 调用forward方法获取结果，forward变长参数支持多个输入，forward的结果调用toTensor变成tensor
     final Tensor cFeature = vgg_encoder.forward(IValue.from(contentTensor)).toTensor();
-4.5 结果tensor再转换成int float等数组
     int[] rstwh = whTensor.getDataAsIntArray();
     也可以把tensor用于进一步的输入
-4.6 如果输出是多输出，用toDictStringKey();
     Map<String, IValue> outTensors = decoder.forward(IValue.from(cFeature), IValue.from(sFeature), IValue.from(1d)).toDictStringKey();
    

#onnx导出
基本方法，相比pytorch导出又增加了更多限制，目前也不用其他框架，就不学，拜拜，
```
torch_model.eval()
torch.onnx.export(torch_model,  # model being run
                  input,  # model input (or a tuple for multiple inputs)
                  path, verbose=True,
                  dynamic_axes={'input_1': {1: 'width',
                                             2: 'height'},

                                 'input_2': {1: 'width',
                                             2: 'height'},

                                 'im': {0: 'width',
                                              1: 'height'}
                                 } # 指定尺寸动态变化的输入或输出tensor的维度，默认不能动态变化
                  )
import o
# Load the ONNX model
model = onnx.load(pa
# Check that the IR is well formed
onnx.checker.check_model(mod
# Print a human readable representation of the graph
onnx.helper.printable_graph(model.graph)
print('导出oxx模型并验证完成， path = \n', path)
```
#mnn导出
目前只能考虑放弃自己弄，或者使用别人弄好的
需要自己编译so，困难重重 没成功
并且 一般编译出来的so也不一定优化效果好，自己尝试其它人的so + 导出的mnn结果不如直接用pytorch的
估计这个需要对他们的框架使用有相当多的了解才能做好，并且需要C++知识
